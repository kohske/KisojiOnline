<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="@kohske" />


<title>ミュラーリヤー実験</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>







<style type="text/css">
@font-face {
font-family: 'Open Sans';
font-style: italic;
font-weight: 400;
font-stretch: normal;
src: url(data:font/ttf;base64,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AFgAAAYCBh8ALwArQBcsLwpyIxwBcioBLi4DBAQnFQZyEQoBcgArMisyMhEzMhEzMysyKzIwMTMTIz8CPgMzMhYXByYmIyIGBwchNz4DMzIWFwcmJiMiBgcHMwcjAyMTIQNYzb8OyxgXQVh1TDJpISseRChVYRwZAdgYF0BYdkwzaCItHEYnVWEbGuwY7cynzP4qzQPJRz1qZotTJBcPfwsRX4Fub2eKUyQXD38LEV+Bbn/8NwPJ/DcA//8AWAAABxoGHwAmAPAAAAAHAEwE/QAA//8AWAAABycGHwAmAPAAAAAHAE8E/QAA//8AWAAABJoGHwAmAO8AAAAHAEwCfQAA//8AWAAABKcGHwAmAO8AAAAHAE8CfQAA//8AG//vAoYDhgAHAOX/Tvys//8AgwAAAh0DbAAHAHr/Vfyu////2gAAAngDfwAHAHT/Tvys//8AAv/zAogDgAAHAHX/Yfys////+QAAAoEDcwAHANv/Y/ys//8AFP/yApMDbwAHANz/WPys//8AI//xApMDewAHAOb/TPys//8APwABAr8DbgAHAN3/WPyr/////v/0AoADfwAHAN7/TPyu//8ADv/xAnwDewAHAOf/Tvys//8Ae//sBEkFzQAGABMEAP//AM4ABQMpBbsABgAUpAX////gAAAEDAXLAAYAFdgA//8AAP/sBAYFywAGABbTAP//AA0AAARHBbcABgAX/wD//wAm/+wEJAW2AAYAGNoA//8AZP/sBD8FywAGABniAP//AIEAAARTBbYABgAa1AD//wBE/+wEPQXNAAYAG+gA//8ARf/sBBIFywAGABzlAP//AJYCOwMBBdIABwDl/8n++P//AO8CSgKJBbYABwB6/8H++P//AFECTALvBcsABwB0/8X++P//AGkCPwLvBcwABwB1/8j++P//AGECTALpBb8ABwDb/8v++P//AIYCPgMFBbsABwDc/8r++P//AKYCPQMWBccABwDm/8/++P//ALcCTgM3BbsABwDd/9D++P//AHYCPgL4BckABwDe/8T++P//AJECPQL/BccABwDn/9H++P///6MAAAN8BbYCBgASAAAAAAABAAABFACQABYAdgAFAAIAEAAvAJoAAAMbD4MAAwABAAAAAAAAAAAAAAApAEYAnwENAYkB/wISAjwCZgKXArYC0gLkAv8DEgNUA30DuQQR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) format('truetype');
}
@font-face {
font-family: 'Open Sans';
font-style: italic;
font-weight: 700;
font-stretch: normal;
src: url(data:font/ttf;base64,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) format('truetype');
}
@font-face {
font-family: 'Open Sans';
font-style: normal;
font-weight: 400;
font-stretch: normal;
src: url(data:font/ttf;base64,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) format('truetype');
}
@font-face {
font-family: 'Open Sans';
font-style: normal;
font-weight: 700;
font-stretch: normal;
src: url(data:font/ttf;base64,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) format('truetype');
}

.jspsych-display-element {
display: flex;
flex-direction: column;
overflow-y: auto;
}
.jspsych-display-element:focus {
outline: none;
}
.jspsych-content-wrapper {
display: flex;
margin: auto;
flex: 1 1 100%;
width: 100%;
}
.jspsych-content {
max-width: 95%; 
text-align: center;
margin: auto; 
}
.jspsych-top {
align-items: flex-start;
}
.jspsych-middle {
align-items: center;
}

.jspsych-display-element {
font-family: 'Open Sans', 'Arial', sans-serif;
font-size: 18px;
line-height: 1.6em;
}

.jspsych-display-element input[type="text"] {
font-family: 'Open Sans', 'Arial', sans-serif;
font-size: 14px;
}

.jspsych-btn {
display: inline-block;
padding: 6px 12px;
margin: 0px;
font-size: 14px;
font-weight: 400;
font-family: 'Open Sans', 'Arial', sans-serif;
cursor: pointer;
line-height: 1.4;
text-align: center;
white-space: nowrap;
vertical-align: middle;
background-image: none;
border: 1px solid transparent;
border-radius: 4px;
color: #333;
background-color: #fff;
border-color: #ccc;
}

@media (hover: hover) {
.jspsych-btn:hover {
background-color: #ddd;
border-color: #aaa;
}
}
.jspsych-btn:active {
background-color: #ddd;
border-color:#000000;
}
.jspsych-btn:disabled {
background-color: #eee;
color: #aaa;
border-color: #ccc;
cursor: not-allowed;
}

.jspsych-slider {
appearance: none;
-webkit-appearance: none; -moz-appearance: none;
width: 100%; background: transparent; }
.jspsych-slider:focus {
outline: none;
}

.jspsych-slider::-webkit-slider-runnable-track {
appearance: none;
-webkit-appearance: none;
width: 100%;
height: 8px;
cursor: pointer;
background: #eee;
box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
border-radius: 2px;
border: 1px solid #aaa;
}
.jspsych-slider::-moz-range-track {
appearance: none;
width: 100%;
height: 8px;
cursor: pointer;
background: #eee;
box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
border-radius: 2px;
border: 1px solid #aaa;
}
.jspsych-slider::-ms-track {
appearance: none;
width: 99%;
height: 14px;
cursor: pointer;
background: #eee;
box-shadow: 0px 0px 0px #000000, 0px 0px 0px #0d0d0d;
border-radius: 2px;
border: 1px solid #aaa;
}

.jspsych-slider::-webkit-slider-thumb {
border: 1px solid #666;
height: 24px;
width: 15px;
border-radius: 5px;
background: #ffffff;
cursor: pointer;
-webkit-appearance: none;
margin-top: -9px;
}
.jspsych-slider::-moz-range-thumb {
border: 1px solid #666;
height: 24px;
width: 15px;
border-radius: 5px;
background: #ffffff;
cursor: pointer;
}
.jspsych-slider::-ms-thumb {
border: 1px solid #666;
height: 20px;
width: 15px;
border-radius: 5px;
background: #ffffff;
cursor: pointer;
margin-top: -2px;
}

#jspsych-progressbar-container {
color: #555;
border-bottom: 1px solid #dedede;
background-color: #f9f9f9;
margin-bottom: 1em;
text-align: center;
padding: 8px 0px;
width: 100%;
line-height: 1em;
}
#jspsych-progressbar-container span {
font-size: 14px;
padding-right: 14px;
}
#jspsych-progressbar-outer {
background-color: #eee;
width: 50%;
margin: auto;
height: 14px;
display: inline-block;
vertical-align: middle;
box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}
#jspsych-progressbar-inner {
background-color: #aaa;
width: 0%;
height: 100%;
}

#jspsych-data-display {
text-align: left;
}
</style>




</head>

<body>




<h1 class="title toc-ignore">ミュラーリヤー実験</h1>
<h4 class="author"><span class="citation">@kohske</span></h4>
<h4 class="date">2020/4/5</h4>



<script>window.jsPsych = (function() {

  var core = {};

  core.version = function() { return "6.3.0" };

  //
  // private variables
  //

  // options
  var opts = {};
  // experiment timeline
  var timeline;
  // flow control
  var global_trial_index = 0;
  var current_trial = {};
  var current_trial_finished = false;
  // target DOM element
  var DOM_container;
  var DOM_target;
  // time that the experiment began
  var exp_start_time;
  // is the experiment paused?
  var paused = false;
  var waiting = false;
  // done loading?
  var loaded = false;
  var loadfail = false;
  // is the page retrieved directly via file:// protocol (true) or hosted on a server (false)?
  var file_protocol = false;

  // storing a single webaudio context to prevent problems with multiple inits
  // of jsPsych
  core.webaudio_context = null;
  // temporary patch for Safari
  if (typeof window !== 'undefined' && window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext')) {
    window.AudioContext = webkitAudioContext;
  }
  // end patch
  core.webaudio_context = (typeof window !== 'undefined' && typeof window.AudioContext !== 'undefined') ? new AudioContext() : null;

  // enumerated variables for special parameter types
  core.ALL_KEYS = 'allkeys';
  core.NO_KEYS = 'none';

  //
  // public methods
  //

  core.init = function(options) {
    function init() {
      if(typeof options.timeline === 'undefined'){
        console.error('No timeline declared in jsPsych.init. Cannot start experiment.')
      }
  
      if(options.timeline.length == 0){
        console.error('No trials have been added to the timeline (the timeline is an empty array). Cannot start experiment.')
      }
  
      // reset variables
      timeline = null;
      global_trial_index = 0;
      current_trial = {};
      current_trial_finished = false;
      paused = false;
      waiting = false;
      loaded = false;
      loadfail = false;
      file_protocol = false;
      jsPsych.data.reset();
  
      var defaults = {
        'display_element': undefined,
        'on_finish': function(data) {
          return undefined;
        },
        'on_trial_start': function(trial) {
          return undefined;
        },
        'on_trial_finish': function() {
          return undefined;
        },
        'on_data_update': function(data) {
          return undefined;
        },
        'on_interaction_data_update': function(data){
          return undefined;
        },
        'on_close': function(){
          return undefined;
        },
        'use_webaudio': true,
        'exclusions': {},
        'show_progress_bar': false,
        'message_progress_bar': 'Completion Progress',
        'auto_update_progress_bar': true,        
        'default_iti': 0,
        'minimum_valid_rt': 0,
        'experiment_width': null,
        'override_safe_mode': false,
        'case_sensitive_responses': false,
        'extensions': []
      };

      // detect whether page is running in browser as a local file, and if so, disable web audio and video preloading to prevent CORS issues
      if (window.location.protocol == 'file:' && (options.override_safe_mode === false || typeof options.override_safe_mode == 'undefined')) {
        options.use_webaudio = false;
        file_protocol = true;
        console.warn("jsPsych detected that it is running via the file:// protocol and not on a web server. "+
          "To prevent issues with cross-origin requests, Web Audio and video preloading have been disabled. "+
          "If you would like to override this setting, you can set 'override_safe_mode' to 'true' in jsPsych.init. "+
          "For more information, see: https://www.jspsych.org/overview/running-experiments");
      }

      // override default options if user specifies an option
      opts = Object.assign({}, defaults, options);

      // set DOM element where jsPsych will render content
      // if undefined, then jsPsych will use the <body> tag and the entire page
      if(typeof opts.display_element == 'undefined'){
        // check if there is a body element on the page
        var body = document.querySelector('body');
        if (body === null) {
          document.documentElement.appendChild(document.createElement('body'));
        }
        // using the full page, so we need the HTML element to
        // have 100% height, and body to be full width and height with
        // no margin
        document.querySelector('html').style.height = '100%';
        document.querySelector('body').style.margin = '0px';
        document.querySelector('body').style.height = '100%';
        document.querySelector('body').style.width = '100%';
        opts.display_element = document.querySelector('body');
      } else {
        // make sure that the display element exists on the page
        var display;
        if (opts.display_element instanceof Element) {
          var display = opts.display_element;
        } else {
          var display = document.querySelector('#' + opts.display_element);
        }
        if(display === null) {
          console.error('The display_element specified in jsPsych.init() does not exist in the DOM.');
        } else {
          opts.display_element = display;
        }
      }
      opts.display_element.innerHTML = '<div class="jspsych-content-wrapper"><div id="jspsych-content"></div></div>';
      DOM_container = opts.display_element;
      DOM_target = document.querySelector('#jspsych-content');
    

      // add tabIndex attribute to scope event listeners
      opts.display_element.tabIndex = 0;

      // add CSS class to DOM_target
      if(opts.display_element.className.indexOf('jspsych-display-element') == -1){
        opts.display_element.className += ' jspsych-display-element';
      }
      DOM_target.className += 'jspsych-content';

      // set experiment_width if not null
      if(opts.experiment_width !== null){
        DOM_target.style.width = opts.experiment_width + "px";
      }

      // create experiment timeline
      timeline = new TimelineNode({
        timeline: opts.timeline
      });

      // initialize audio context based on options and browser capabilities
      jsPsych.pluginAPI.initAudio();

      // below code resets event listeners that may have lingered from
      // a previous incomplete experiment loaded in same DOM.
      jsPsych.pluginAPI.reset(opts.display_element);
      // create keyboard event listeners
      jsPsych.pluginAPI.createKeyboardEventListeners(opts.display_element);
      // create listeners for user browser interaction
      jsPsych.data.createInteractionListeners();

      // add event for closing window
      window.addEventListener('beforeunload', opts.on_close);

      // check exclusions before continuing
      checkExclusions(opts.exclusions,
        function(){
          // success! user can continue...
          // start experiment
          loadExtensions();
        },
        function(){
          // fail. incompatible user.
        }
      );

      function loadExtensions() {
        // run the .initialize method of any extensions that are in use
        // these should return a Promise to indicate when loading is complete
        if (opts.extensions.length == 0) {
          startExperiment();
        } else {
          var loaded_extensions = 0;
          for (var i = 0; i < opts.extensions.length; i++) {
            var ext_params = opts.extensions[i].params;
            if (!ext_params) {
              ext_params = {}
            }
            jsPsych.extensions[opts.extensions[i].type].initialize(ext_params)
              .then(() => {
                loaded_extensions++;
                if (loaded_extensions == opts.extensions.length) {
                  startExperiment();
                }
              })
              .catch((error_message) => {
                console.error(error_message);
              })
          }
        }
      }

    };
    
    // execute init() when the document is ready
    if (document.readyState === "complete") {
      init();
    } else {
      window.addEventListener("load", init);
    }
  }

  core.progress = function() {

    var percent_complete = typeof timeline == 'undefined' ? 0 : timeline.percentComplete();

    var obj = {
      "total_trials": typeof timeline == 'undefined' ? undefined : timeline.length(),
      "current_trial_global": global_trial_index,
      "percent_complete": percent_complete
    };

    return obj;
  };

  core.startTime = function() {
    return exp_start_time;
  };

  core.totalTime = function() {
    if(typeof exp_start_time == 'undefined'){ return 0; }
    return (new Date()).getTime() - exp_start_time.getTime();
  };

  core.getDisplayElement = function() {
    return DOM_target;
  };

  core.getDisplayContainerElement = function(){
    return DOM_container;
  }

  core.finishTrial = function(data) {

    if(current_trial_finished){ return; }
    current_trial_finished = true;

    // remove any CSS classes that were added to the DOM via css_classes parameter
    if(typeof current_trial.css_classes !== 'undefined' && Array.isArray(current_trial.css_classes)){
      DOM_target.classList.remove(...current_trial.css_classes);
    }

    // write the data from the trial
    data = typeof data == 'undefined' ? {} : data;
    jsPsych.data.write(data);

    // get back the data with all of the defaults in
    var trial_data = jsPsych.data.get().filter({trial_index: global_trial_index});

    // for trial-level callbacks, we just want to pass in a reference to the values
    // of the DataCollection, for easy access and editing.
    var trial_data_values = trial_data.values()[0];

    if(typeof current_trial.save_trial_parameters == 'object'){
      var keys = Object.keys(current_trial.save_trial_parameters);
      for(var i=0; i<keys.length; i++){
        var key_val = current_trial.save_trial_parameters[keys[i]];
        if(key_val === true){
          if(typeof current_trial[keys[i]] == 'undefined'){
            console.warn(`Invalid parameter specified in save_trial_parameters. Trial has no property called "${keys[i]}".`)
          } else if(typeof current_trial[keys[i]] == 'function'){
            trial_data_values[keys[i]] = current_trial[keys[i]].toString();
          } else {
            trial_data_values[keys[i]] = current_trial[keys[i]];
          }
        }
        if(key_val === false){
          // we don't allow internal_node_id or trial_index to be deleted because it would break other things
          if(keys[i] !== 'internal_node_id' && keys[i] !== 'trial_index'){
            delete trial_data_values[keys[i]];
          }
        }
      }
    }
    // handle extension callbacks
    if(Array.isArray(current_trial.extensions)){
      for(var i=0; i<current_trial.extensions.length; i++){
        var ext_data_values = jsPsych.extensions[current_trial.extensions[i].type].on_finish(current_trial.extensions[i].params);
        Object.assign(trial_data_values, ext_data_values);
      }
    }
    
    // about to execute lots of callbacks, so switch context.
    jsPsych.internal.call_immediate = true;

    // handle callback at plugin level
    if (typeof current_trial.on_finish === 'function') {
      current_trial.on_finish(trial_data_values);
    }

    // handle callback at whole-experiment level
    opts.on_trial_finish(trial_data_values);

    // after the above callbacks are complete, then the data should be finalized
    // for this trial. call the on_data_update handler, passing in the same
    // data object that just went through the trial's finish handlers.
    opts.on_data_update(trial_data_values);

    // done with callbacks
    jsPsych.internal.call_immediate = false;

    // wait for iti
    if (typeof current_trial.post_trial_gap === null || typeof current_trial.post_trial_gap === 'undefined') {
      if (opts.default_iti > 0) {
        setTimeout(nextTrial, opts.default_iti);
      } else {
        nextTrial();
      }
    } else {
      if (current_trial.post_trial_gap > 0) {
        setTimeout(nextTrial, current_trial.post_trial_gap);
      } else {
        nextTrial();
      }
    }
  }

  core.endExperiment = function(end_message) {
    timeline.end_message = end_message;
    timeline.end();
    jsPsych.pluginAPI.cancelAllKeyboardResponses();
    jsPsych.pluginAPI.clearAllTimeouts();
    core.finishTrial();
  }

  core.endCurrentTimeline = function() {
    timeline.endActiveNode();
  }

  core.currentTrial = function() {
    return current_trial;
  };

  core.initSettings = function() {
    return opts;
  };

  core.currentTimelineNodeID = function() {
    return timeline.activeID();
  };

  core.timelineVariable = function(varname, immediate){
    if(typeof immediate == 'undefined'){ immediate = false; }
    if(jsPsych.internal.call_immediate || immediate === true){
      return timeline.timelineVariable(varname);
    } else {
      return function() { return timeline.timelineVariable(varname); }
    }
  }

  core.allTimelineVariables = function(){
    return timeline.allTimelineVariables();
  }

  core.addNodeToEndOfTimeline = function(new_timeline, preload_callback){
    timeline.insert(new_timeline);
  }

  core.pauseExperiment = function(){
    paused = true;
  }

  core.resumeExperiment = function(){
    paused = false;
    if(waiting){
      waiting = false;
      nextTrial();
    }
  }

  core.loadFail = function(message){
    message = message || '<p>The experiment failed to load.</p>';
    loadfail = true;
    DOM_target.innerHTML = message;
  }

  core.getSafeModeStatus = function() {
    return file_protocol;
  }

  function TimelineNode(parameters, parent, relativeID) {

    // a unique ID for this node, relative to the parent
    var relative_id;

    // store the parent for this node
    var parent_node;

    // parameters for the trial if the node contains a trial
    var trial_parameters;

    // parameters for nodes that contain timelines
    var timeline_parameters;

    // stores trial information on a node that contains a timeline
    // used for adding new trials
    var node_trial_data;

    // track progress through the node
    var progress = {
      current_location: -1, // where on the timeline (which timelinenode)
      current_variable_set: 0, // which set of variables to use from timeline_variables
      current_repetition: 0, // how many times through the variable set on this run of the node
      current_iteration: 0, // how many times this node has been revisited
      done: false
    }

    // reference to self
    var self = this;

    // recursively get the next trial to run.
    // if this node is a leaf (trial), then return the trial.
    // otherwise, recursively find the next trial in the child timeline.
    this.trial = function() {
      if (typeof timeline_parameters == 'undefined') {
        // returns a clone of the trial_parameters to
        // protect functions.
        return jsPsych.utils.deepCopy(trial_parameters);
      } else {
        if (progress.current_location >= timeline_parameters.timeline.length) {
          return null;
        } else {
          return timeline_parameters.timeline[progress.current_location].trial();
        }
      }
    }

    this.markCurrentTrialComplete = function() {
      if(typeof timeline_parameters == 'undefined'){
        progress.done = true;
      } else {
        timeline_parameters.timeline[progress.current_location].markCurrentTrialComplete();
      }
    }

    this.nextRepetiton = function() {
      this.setTimelineVariablesOrder();
      progress.current_location = -1;
      progress.current_variable_set = 0;
      progress.current_repetition++;
      for (var i = 0; i < timeline_parameters.timeline.length; i++) {
        timeline_parameters.timeline[i].reset();
      }
    }

    // set the order for going through the timeline variables array
    this.setTimelineVariablesOrder = function() {

      // check to make sure this node has variables
      if(typeof timeline_parameters === 'undefined' || typeof timeline_parameters.timeline_variables === 'undefined'){
        return;
      }

      var order = [];
      for(var i=0; i<timeline_parameters.timeline_variables.length; i++){
        order.push(i);
      }

      if(typeof timeline_parameters.sample !== 'undefined'){
        if(timeline_parameters.sample.type == 'custom'){
          order = timeline_parameters.sample.fn(order);
        } else if(timeline_parameters.sample.type == 'with-replacement'){
          order = jsPsych.randomization.sampleWithReplacement(order, timeline_parameters.sample.size, timeline_parameters.sample.weights);
        } else if(timeline_parameters.sample.type == 'without-replacement'){
          order = jsPsych.randomization.sampleWithoutReplacement(order, timeline_parameters.sample.size);
        } else if(timeline_parameters.sample.type == 'fixed-repetitions'){
          order = jsPsych.randomization.repeat(order, timeline_parameters.sample.size, false);
        } else if(timeline_parameters.sample.type == 'alternate-groups'){
          order = jsPsych.randomization.shuffleAlternateGroups(timeline_parameters.sample.groups, timeline_parameters.sample.randomize_group_order);
        } else {
          console.error('Invalid type in timeline sample parameters. Valid options for type are "custom", "with-replacement", "without-replacement", "fixed-repetitions", and "alternate-groups"');
        }
      }

      if(timeline_parameters.randomize_order) {
        order = jsPsych.randomization.shuffle(order);
      }

      progress.order = order;
    }

    // next variable set
    this.nextSet = function() {
      progress.current_location = -1;
      progress.current_variable_set++;
      for (var i = 0; i < timeline_parameters.timeline.length; i++) {
        timeline_parameters.timeline[i].reset();
      }
    }

    // update the current trial node to be completed
    // returns true if the node is complete after advance (all subnodes are also complete)
    // returns false otherwise
    this.advance = function () {

      // first check to see if done
      if (progress.done) {
        return true;
      }

      // if node has not started yet (progress.current_location == -1),
      // then try to start the node.
      if (progress.current_location == -1) {
        // check for on_timeline_start and conditonal function on nodes with timelines
        if (typeof timeline_parameters !== 'undefined') {
          // only run the conditional function if this is the first repetition of the timeline when
          // repetitions > 1, and only when on the first variable set
          if (typeof timeline_parameters.conditional_function !== 'undefined' && progress.current_repetition == 0 && progress.current_variable_set == 0) {
            jsPsych.internal.call_immediate = true;
            var conditional_result = timeline_parameters.conditional_function();
            jsPsych.internal.call_immediate = false;
            // if the conditional_function() returns false, then the timeline
            // doesn't run and is marked as complete.
            if (conditional_result == false) {
              progress.done = true;
              return true;
            }
          }

          // if we reach this point then the node has its own timeline and will start
          // so we need to check if there is an on_timeline_start function if we are on the first variable set
          if (typeof timeline_parameters.on_timeline_start !== 'undefined' && progress.current_variable_set == 0) {
            timeline_parameters.on_timeline_start();
          }
          

        }
        // if we reach this point, then either the node doesn't have a timeline of the 
        // conditional function returned true and it can start
        progress.current_location = 0;
        // call advance again on this node now that it is pointing to a new location
        return this.advance();
      }

      // if this node has a timeline, propogate down to the current trial.
      if (typeof timeline_parameters !== 'undefined') {

        var have_node_to_run = false;
        // keep incrementing the location in the timeline until one of the nodes reached is incomplete
        while (progress.current_location < timeline_parameters.timeline.length && have_node_to_run == false) {

          // check to see if the node currently pointed at is done
          var target_complete = timeline_parameters.timeline[progress.current_location].advance();
          if (!target_complete) {
            have_node_to_run = true;
            return false;
          } else {
            progress.current_location++;
          }

        }

        // if we've reached the end of the timeline (which, if the code is here, we have)

        // there are a few steps to see what to do next...

        // first, check the timeline_variables to see if we need to loop through again
        // with a new set of variables
        if (progress.current_variable_set < progress.order.length - 1) {
          // reset the progress of the node to be with the new set
          this.nextSet();
          // then try to advance this node again.
          return this.advance();
        }

        // if we're all done with the timeline_variables, then check to see if there are more repetitions
        else if (progress.current_repetition < timeline_parameters.repetitions - 1) {
          this.nextRepetiton();
          // check to see if there is an on_timeline_finish function
          if (typeof timeline_parameters.on_timeline_finish !== 'undefined') {
            timeline_parameters.on_timeline_finish();
          }
          return this.advance();
        }


        // if we're all done with the repetitions...
        else {
          // check to see if there is an on_timeline_finish function
          if (typeof timeline_parameters.on_timeline_finish !== 'undefined') {
            timeline_parameters.on_timeline_finish();
          }

          // if we're all done with the repetitions, check if there is a loop function.
          if (typeof timeline_parameters.loop_function !== 'undefined') {
            jsPsych.internal.call_immediate = true;
            if (timeline_parameters.loop_function(this.generatedData())) {
              this.reset();
              jsPsych.internal.call_immediate = false;
              return parent_node.advance();
            } else {
              progress.done = true;
              jsPsych.internal.call_immediate = false;
              return true;
            }
          }


        }

        // no more loops on this timeline, we're done!
        progress.done = true;
        return true;
      }
    }

    // check the status of the done flag
    this.isComplete = function() {
      return progress.done;
    }

    // getter method for timeline variables
    this.getTimelineVariableValue = function(variable_name){
      if(typeof timeline_parameters == 'undefined'){
        return undefined;
      }
      var v = timeline_parameters.timeline_variables[progress.order[progress.current_variable_set]][variable_name];
      return v;
    }

    // recursive upward search for timeline variables
    this.findTimelineVariable = function(variable_name){
      var v = this.getTimelineVariableValue(variable_name);
      if(typeof v == 'undefined'){
        if(typeof parent_node !== 'undefined'){
          return parent_node.findTimelineVariable(variable_name);
        } else {
          return undefined;
        }
      } else {
        return v;
      }
    }

    // recursive downward search for active trial to extract timeline variable
    this.timelineVariable = function(variable_name){
      if(typeof timeline_parameters == 'undefined'){
        return this.findTimelineVariable(variable_name);
      } else {
        // if progress.current_location is -1, then the timeline variable is being evaluated
        // in a function that runs prior to the trial starting, so we should treat that trial
        // as being the active trial for purposes of finding the value of the timeline variable
        var loc = Math.max(0, progress.current_location);
        // if loc is greater than the number of elements on this timeline, then the timeline
        // variable is being evaluated in a function that runs after the trial on the timeline
        // are complete but before advancing to the next (like a loop_function).
        // treat the last active trial as the active trial for this purpose.
        if(loc == timeline_parameters.timeline.length){
          loc = loc - 1;
        }
        // now find the variable
        return timeline_parameters.timeline[loc].timelineVariable(variable_name); 
      }
    }

    // recursively get all the timeline variables for this trial
    this.allTimelineVariables = function(){
      var all_tvs = this.allTimelineVariablesNames();
      var all_tvs_vals = {};
      for(var i=0; i<all_tvs.length; i++){
        all_tvs_vals[all_tvs[i]] = this.timelineVariable(all_tvs[i])
      }
      return all_tvs_vals;
    }

    // helper to get all the names at this stage.
    this.allTimelineVariablesNames = function(so_far){
      if(typeof so_far == 'undefined'){
        so_far = [];
      }
      if(typeof timeline_parameters !== 'undefined'){
        so_far = so_far.concat(Object.keys(timeline_parameters.timeline_variables[progress.order[progress.current_variable_set]]));
        // if progress.current_location is -1, then the timeline variable is being evaluated
        // in a function that runs prior to the trial starting, so we should treat that trial
        // as being the active trial for purposes of finding the value of the timeline variable
        var loc = Math.max(0, progress.current_location);
        // if loc is greater than the number of elements on this timeline, then the timeline
        // variable is being evaluated in a function that runs after the trial on the timeline
        // are complete but before advancing to the next (like a loop_function).
        // treat the last active trial as the active trial for this purpose.
        if(loc == timeline_parameters.timeline.length){
          loc = loc - 1;
        }
        // now find the variable
        return timeline_parameters.timeline[loc].allTimelineVariablesNames(so_far);
      }
      if(typeof timeline_parameters == 'undefined'){
        return so_far;
      }
    }

    // recursively get the number of **trials** contained in the timeline
    // assuming that while loops execute exactly once and if conditionals
    // always run
    this.length = function() {
      var length = 0;
      if (typeof timeline_parameters !== 'undefined') {
        for (var i = 0; i < timeline_parameters.timeline.length; i++) {
          length += timeline_parameters.timeline[i].length();
        }
      } else {
        return 1;
      }
      return length;
    }

    // return the percentage of trials completed, grouped at the first child level
    // counts a set of trials as complete when the child node is done
    this.percentComplete = function() {
      var total_trials = this.length();
      var completed_trials = 0;
      for (var i = 0; i < timeline_parameters.timeline.length; i++) {
        if (timeline_parameters.timeline[i].isComplete()) {
          completed_trials += timeline_parameters.timeline[i].length();
        }
      }
      return (completed_trials / total_trials * 100)
    }

    // resets the node and all subnodes to original state
    // but increments the current_iteration counter
    this.reset = function() {
      progress.current_location = -1;
      progress.current_repetition = 0;
      progress.current_variable_set = 0;
      progress.current_iteration++;
      progress.done = false;
      this.setTimelineVariablesOrder();
      if (typeof timeline_parameters != 'undefined') {
        for (var i = 0; i < timeline_parameters.timeline.length; i++) {
          timeline_parameters.timeline[i].reset();
        }
      }

    }

    // mark this node as finished
    this.end = function() {
      progress.done = true;
    }

    // recursively end whatever sub-node is running the current trial
    this.endActiveNode = function() {
      if (typeof timeline_parameters == 'undefined') {
        this.end();
        parent_node.end();
      } else {
        timeline_parameters.timeline[progress.current_location].endActiveNode();
      }
    }

    // get a unique ID associated with this node
    // the ID reflects the current iteration through this node.
    this.ID = function() {
      var id = "";
      if (typeof parent_node == 'undefined') {
        return "0." + progress.current_iteration;
      } else {
        id += parent_node.ID() + "-";
        id += relative_id + "." + progress.current_iteration;
        return id;
      }
    }

    // get the ID of the active trial
    this.activeID = function() {
      if (typeof timeline_parameters == 'undefined') {
        return this.ID();
      } else {
        return timeline_parameters.timeline[progress.current_location].activeID();
      }
    }

    // get all the data generated within this node
    this.generatedData = function() {
      return jsPsych.data.getDataByTimelineNode(this.ID());
    }

    // get all the trials of a particular type
    this.trialsOfType = function(type) {
      if (typeof timeline_parameters == 'undefined'){
        if (trial_parameters.type == type) {
          return trial_parameters;
        } else {
          return [];
        }
      } else {
        var trials = [];
        for (var i = 0; i < timeline_parameters.timeline.length; i++) {
          var t = timeline_parameters.timeline[i].trialsOfType(type);
          trials = trials.concat(t);
        }
        return trials;
      }
    }

    // add new trials to end of this timeline
    this.insert = function(parameters){
      if(typeof timeline_parameters == 'undefined'){
        console.error('Cannot add new trials to a trial-level node.');
      } else {
        timeline_parameters.timeline.push(
          new TimelineNode(Object.assign({}, node_trial_data, parameters), self, timeline_parameters.timeline.length)
        );
      }
    }

    // constructor
    var _construct = function() {

      // store a link to the parent of this node
      parent_node = parent;

      // create the ID for this node
      if (typeof parent == 'undefined') {
        relative_id = 0;
      } else {
        relative_id = relativeID;
      }

      // check if there is a timeline parameter
      // if there is, then this node has its own timeline
      if ((typeof parameters.timeline !== 'undefined') || (typeof jsPsych.plugins[trial_type] == 'function')) {

        // create timeline properties
        timeline_parameters = {
          timeline: [],
          loop_function: parameters.loop_function,
          conditional_function: parameters.conditional_function,
          sample: parameters.sample,
          randomize_order: typeof parameters.randomize_order == 'undefined' ? false : parameters.randomize_order,
          repetitions: typeof parameters.repetitions == 'undefined' ? 1 : parameters.repetitions,
          timeline_variables: typeof parameters.timeline_variables == 'undefined' ? [{}] : parameters.timeline_variables,
          on_timeline_finish: parameters.on_timeline_finish,
          on_timeline_start: parameters.on_timeline_start,
        };

        self.setTimelineVariablesOrder();

        // extract all of the node level data and parameters
        // but remove all of the timeline-level specific information
        // since this will be used to copy things down hierarchically
        var node_data = Object.assign({}, parameters);
        delete node_data.timeline;
        delete node_data.conditional_function;
        delete node_data.loop_function;
        delete node_data.randomize_order;
        delete node_data.repetitions;
        delete node_data.timeline_variables;
        delete node_data.sample;
        delete node_data.on_timeline_start;
        delete node_data.on_timeline_finish;
        node_trial_data = node_data; // store for later...

        // create a TimelineNode for each element in the timeline
        for (var i = 0; i < parameters.timeline.length; i++) {
          // merge parameters
          var merged_parameters = Object.assign({}, node_data, parameters.timeline[i]);
          // merge any data from the parent node into child nodes
          if(typeof node_data.data == 'object' && typeof parameters.timeline[i].data == 'object'){
            var merged_data = Object.assign({}, node_data.data, parameters.timeline[i].data);
            merged_parameters.data = merged_data;
          }
          timeline_parameters.timeline.push(new TimelineNode(merged_parameters, self, i));
        }
      }
      // if there is no timeline parameter, then this node is a trial node
      else {
        // check to see if a valid trial type is defined
        var trial_type = parameters.type;
        if (typeof trial_type == 'undefined') {
          console.error('Trial level node is missing the "type" parameter. The parameters for the node are: ' + JSON.stringify(parameters));
        } else if ((typeof jsPsych.plugins[trial_type] == 'undefined') && (trial_type.toString().replace(/\s/g,'') != "function(){returntimeline.timelineVariable(varname);}")) {
          console.error('No plugin loaded for trials of type "' + trial_type + '"');
        }
        // create a deep copy of the parameters for the trial
        trial_parameters = Object.assign({}, parameters);
      }

    }();
  }

  function startExperiment() {

    loaded = true;

    // show progress bar if requested
    if (opts.show_progress_bar === true) {
      drawProgressBar(opts.message_progress_bar);
    }

    // record the start time
    exp_start_time = new Date();

    // begin!
    timeline.advance();
    doTrial(timeline.trial());

  }

  function finishExperiment() {

    if(typeof timeline.end_message !== 'undefined'){
      DOM_target.innerHTML = timeline.end_message;
    }

    opts.on_finish(jsPsych.data.get());

  }

  function nextTrial() {
    // if experiment is paused, don't do anything.
    if(paused) {
      waiting = true;
      return;
    }

    global_trial_index++;

    // advance timeline
    timeline.markCurrentTrialComplete();
    var complete = timeline.advance();

    // update progress bar if shown
    if (opts.show_progress_bar === true && opts.auto_update_progress_bar == true) {
      updateProgressBar();
    }

    // check if experiment is over
    if (complete) {
      finishExperiment();
      return;
    }

    doTrial(timeline.trial());
  }

  function doTrial(trial) {

    current_trial = trial;
    current_trial_finished = false;

    // process all timeline variables for this trial
    evaluateTimelineVariables(trial);

    // evaluate variables that are functions
    evaluateFunctionParameters(trial);

    // get default values for parameters
    setDefaultValues(trial);

    // about to execute callbacks
    jsPsych.internal.call_immediate = true;

    // call experiment wide callback
    opts.on_trial_start(trial);

    // call trial specific callback if it exists
    if(typeof trial.on_start == 'function'){
      trial.on_start(trial);
    }

    // call any on_start functions for extensions
    if(Array.isArray(trial.extensions)){
      for(var i=0; i<trial.extensions.length; i++){
        jsPsych.extensions[trial.extensions[i].type].on_start(current_trial.extensions[i].params);
      }
    }

    // apply the focus to the element containing the experiment.
    DOM_container.focus();

    // reset the scroll on the DOM target
    DOM_target.scrollTop = 0;

    // add CSS classes to the DOM_target if they exist in trial.css_classes
    if(typeof trial.css_classes !== 'undefined'){
      if(!Array.isArray(trial.css_classes) && typeof trial.css_classes == 'string'){
        trial.css_classes = [trial.css_classes];
      }
      if(Array.isArray(trial.css_classes)){
        DOM_target.classList.add(...trial.css_classes)
      }
    }

    // execute trial method
    jsPsych.plugins[trial.type].trial(DOM_target, trial);

    // call trial specific loaded callback if it exists
    if(typeof trial.on_load == 'function'){
      trial.on_load();
    }

    // call any on_load functions for extensions
    if(Array.isArray(trial.extensions)){
      for(var i=0; i<trial.extensions.length; i++){
        jsPsych.extensions[trial.extensions[i].type].on_load(current_trial.extensions[i].params);
      }
    }
    
    // done with callbacks
    jsPsych.internal.call_immediate = false;
  }

  function evaluateTimelineVariables(trial){
    var keys = Object.keys(trial);

    for (var i = 0; i < keys.length; i++) {
      // timeline variables on the root level
      if (typeof trial[keys[i]] == "function" && trial[keys[i]].toString().replace(/\s/g,'') == "function(){returntimeline.timelineVariable(varname);}") {
        trial[keys[i]] = trial[keys[i]].call();
      }
      // timeline variables that are nested in objects
      if (typeof trial[keys[i]] == "object" && trial[keys[i]] !== null){
        evaluateTimelineVariables(trial[keys[i]]);
      }
    }
  }

  function evaluateFunctionParameters(trial){

    // set a flag so that jsPsych.timelineVariable() is immediately executed in this context
    jsPsych.internal.call_immediate = true;

    // first, eval the trial type if it is a function
    // this lets users set the plugin type with a function
    if(typeof trial.type === 'function'){
      trial.type = trial.type.call();
    }

    // now eval the whole trial

    // start by getting a list of the parameters
    var keys = Object.keys(trial);

    // iterate over each parameter
    for (var i = 0; i < keys.length; i++) {
      // check to make sure parameter is not "type", since that was eval'd above.
      if(keys[i] !== 'type'){
        // this if statement is checking to see if the parameter type is expected to be a function, in which case we should NOT evaluate it.
        // the first line checks if the parameter is defined in the universalPluginParameters set
        // the second line checks the plugin-specific parameters
        if(typeof jsPsych.plugins.universalPluginParameters[keys[i]] !== 'undefined' && 
          jsPsych.plugins.universalPluginParameters[keys[i]].type !== jsPsych.plugins.parameterType.FUNCTION ){
          trial[keys[i]] = replaceFunctionsWithValues(trial[keys[i]], null);
        }
        if(typeof jsPsych.plugins[trial.type].info.parameters[keys[i]] !== 'undefined' && 
          jsPsych.plugins[trial.type].info.parameters[keys[i]].type !== jsPsych.plugins.parameterType.FUNCTION){
          trial[keys[i]] = replaceFunctionsWithValues(trial[keys[i]], jsPsych.plugins[trial.type].info.parameters[keys[i]]);
        }
      }
    }
    // reset so jsPsych.timelineVariable() is no longer immediately executed
    jsPsych.internal.call_immediate = false;
  }

  function replaceFunctionsWithValues(obj, info){
    // null typeof is 'object' (?!?!), so need to run this first!
    if(obj === null){
      return obj;
    }
    // arrays 
    else if(Array.isArray(obj)){
      for(var i=0; i<obj.length; i++){
        obj[i] = replaceFunctionsWithValues(obj[i], info);
      }
    }
    // objects
    else if(typeof obj === 'object'){
      var keys = Object.keys(obj);
      if(info == null || !info.nested){
        for(var i=0; i<keys.length; i++){
          obj[keys[i]] = replaceFunctionsWithValues(obj[keys[i]], null)
        }
      } else {
        for(var i=0; i<keys.length; i++){
          if(typeof info.nested[keys[i]] == 'object' && info.nested[keys[i]].type !== jsPsych.plugins.parameterType.FUNCTION){
            obj[keys[i]] = replaceFunctionsWithValues(obj[keys[i]], info.nested[keys[i]])
          }
        }
      }
    }
    else if(typeof obj === 'function'){
      return obj();
    }
    return obj;
  }

  function setDefaultValues(trial){
    for(var param in jsPsych.plugins[trial.type].info.parameters){
      // check if parameter is complex with nested defaults
      if(jsPsych.plugins[trial.type].info.parameters[param].type == jsPsych.plugins.parameterType.COMPLEX){
        if(jsPsych.plugins[trial.type].info.parameters[param].array == true){
          // iterate over each entry in the array
          trial[param].forEach(function(ip, i){
            // check each parameter in the plugin description
            for(var p in jsPsych.plugins[trial.type].info.parameters[param].nested){
              if(typeof trial[param][i][p] == 'undefined' || trial[param][i][p] === null){
                if(typeof jsPsych.plugins[trial.type].info.parameters[param].nested[p].default == 'undefined'){
                  console.error('You must specify a value for the '+p+' parameter (nested in the '+param+' parameter) in the '+trial.type+' plugin.');
                } else {
                  trial[param][i][p] = jsPsych.plugins[trial.type].info.parameters[param].nested[p].default;
                }
              }
            }
          });
        }
      }      
      // if it's not nested, checking is much easier and do that here:
      else if(typeof trial[param] == 'undefined' || trial[param] === null){
        if(typeof jsPsych.plugins[trial.type].info.parameters[param].default == 'undefined'){
          console.error('You must specify a value for the '+param+' parameter in the '+trial.type+' plugin.');
        } else {
          trial[param] = jsPsych.plugins[trial.type].info.parameters[param].default;
        }
      }
    }
  }

  function checkExclusions(exclusions, success, fail){
    var clear = true;

    // MINIMUM SIZE
    if(typeof exclusions.min_width !== 'undefined' || typeof exclusions.min_height !== 'undefined'){
      var mw = typeof exclusions.min_width !== 'undefined' ? exclusions.min_width : 0;
      var mh = typeof exclusions.min_height !== 'undefined' ? exclusions.min_height : 0;
      var w = window.innerWidth;
      var h = window.innerHeight;
      if(w < mw || h < mh){
        clear = false;
        var interval = setInterval(function(){
          var w = window.innerWidth;
          var h = window.innerHeight;
          if(w < mw || h < mh){
            var msg = '<p>Your browser window is too small to complete this experiment. '+
              'Please maximize the size of your browser window. If your browser window is already maximized, '+
              'you will not be able to complete this experiment.</p>'+
              '<p>The minimum width is '+mw+'px. Your current width is '+w+'px.</p>'+
              '<p>The minimum height is '+mh+'px. Your current height is '+h+'px.</p>';
            core.getDisplayElement().innerHTML = msg;
          } else {
            clearInterval(interval);
            core.getDisplayElement().innerHTML = '';
            checkExclusions(exclusions, success, fail);
          }
        }, 100);
        return; // prevents checking other exclusions while this is being fixed
      }
    }

    // WEB AUDIO API
    if(typeof exclusions.audio !== 'undefined' && exclusions.audio) {
      if(window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext')){
        // clear
      } else {
        clear = false;
        var msg = '<p>Your browser does not support the WebAudio API, which means that you will not '+
          'be able to complete the experiment.</p><p>Browsers that support the WebAudio API include '+
          'Chrome, Firefox, Safari, and Edge.</p>';
        core.getDisplayElement().innerHTML = msg;
        fail();
        return;
      }
    }

    // GO?
    if(clear){ success(); }
  }

  function drawProgressBar(msg) {
    document.querySelector('.jspsych-display-element').insertAdjacentHTML('afterbegin',
      '<div id="jspsych-progressbar-container">'+
      '<span>'+
      msg+ 
      '</span>'+
      '<div id="jspsych-progressbar-outer">'+
        '<div id="jspsych-progressbar-inner"></div>'+
      '</div></div>');
  }

  function updateProgressBar() {
    var progress = jsPsych.progress().percent_complete;
    core.setProgressBar(progress / 100);
  }

  var progress_bar_amount = 0;

  core.setProgressBar = function(proportion_complete){
    proportion_complete = Math.max(Math.min(1,proportion_complete),0);
    document.querySelector('#jspsych-progressbar-inner').style.width = (proportion_complete*100) + "%";
    progress_bar_amount = proportion_complete;
  }

  core.getProgressBarCompleted = function(){
    return progress_bar_amount;
  }

  //Leave a trace in the DOM that jspsych was loaded
  document.documentElement.setAttribute('jspsych', 'present');

  return core;
})();

jsPsych.internal = (function() {
  var module = {};

  // this flag is used to determine whether we are in a scope where
  // jsPsych.timelineVariable() should be executed immediately or
  // whether it should return a function to access the variable later.
  module.call_immediate = false;

  return module;
})();

jsPsych.plugins = (function() {

  var module = {};

  // enumerate possible parameter types for plugins
  module.parameterType = {
    BOOL: 0,
    STRING: 1,
    INT: 2,
    FLOAT: 3,
    FUNCTION: 4,
    KEY: 5,
    SELECT: 6,
    HTML_STRING: 7,
    IMAGE: 8,
    AUDIO: 9,
    VIDEO: 10,
    OBJECT: 11,
    COMPLEX: 12,
    TIMELINE: 13
  }

  module.universalPluginParameters = {
    data: {
      type: module.parameterType.OBJECT,
      pretty_name: 'Data',
      default: {},
      description: 'Data to add to this trial (key-value pairs)'
    },
    on_start: {
      type: module.parameterType.FUNCTION,
      pretty_name: 'On start',
      default: function() { return; },
      description: 'Function to execute when trial begins'
    },
    on_finish: {
      type: module.parameterType.FUNCTION,
      pretty_name: 'On finish',
      default: function() { return; },
      description: 'Function to execute when trial is finished'
    },
    on_load: {
      type: module.parameterType.FUNCTION,
      pretty_name: 'On load',
      default: function() { return; },
      description: 'Function to execute after the trial has loaded'
    },
    post_trial_gap: {
      type: module.parameterType.INT,
      pretty_name: 'Post trial gap',
      default: null,
      description: 'Length of gap between the end of this trial and the start of the next trial'
    },
    css_classes: {
      type: module.parameterType.STRING,
      pretty_name: 'Custom CSS classes',
      default: null,
      description: 'A list of CSS classes to add to the jsPsych display element for the duration of this trial'
    }
  }

  return module;
})();

jsPsych.extensions = (function(){
  return {};
})();

jsPsych.data = (function() {

  var module = {};

  // data storage object
  var allData = DataCollection();

  // browser interaction event data
  var interactionData = DataCollection();

  // data properties for all trials
  var dataProperties = {};

  // cache the query_string
  var query_string;

  // DataCollection
  function DataCollection(data){

    var data_collection = {};

    var trials = typeof data === 'undefined' ? [] : data;

    data_collection.push = function(new_data){
      trials.push(new_data);
      return data_collection;
    }

    data_collection.join = function(other_data_collection){
      trials = trials.concat(other_data_collection.values());
      return data_collection;
    }

    data_collection.top = function(){
      if(trials.length <= 1){
        return data_collection;
      } else {
        return DataCollection([trials[trials.length-1]]);
      }
    }

    /**
     * Queries the first n elements in a collection of trials.
     *
     * @param {number} n A positive integer of elements to return. A value of
     *                   n that is less than 1 will throw an error.
     *
     * @return {Array} First n objects of a collection of trials. If fewer than
     *                 n trials are available, the trials.length elements will
     *                 be returned.
     *
     */
    data_collection.first = function(n){
      if (typeof n == 'undefined') { n = 1 }
      if (n < 1) {
        throw `You must query with a positive nonzero integer. Please use a 
               different value for n.`;
      }
      if (trials.length == 0) return DataCollection([]);
      if (n > trials.length) n = trials.length;
      return DataCollection(trials.slice(0, n));
    }

    /**
     * Queries the last n elements in a collection of trials.
     *
     * @param {number} n A positive integer of elements to return. A value of
     *                   n that is less than 1 will throw an error.
     *
     * @return {Array} Last n objects of a collection of trials. If fewer than
     *                 n trials are available, the trials.length elements will
     *                 be returned.
     *
     */
    data_collection.last = function(n) {
      if (typeof n == 'undefined') { n = 1 }
      if (n < 1) {
        throw `You must query with a positive nonzero integer. Please use a 
               different value for n.`;
      }
      if (trials.length == 0) return DataCollection([]);
      if (n > trials.length) n = trials.length;
      return DataCollection(trials.slice(trials.length - n, trials.length));
    }

    data_collection.values = function(){
      return trials;
    }

    data_collection.count = function(){
      return trials.length;
    }

    data_collection.readOnly = function(){
      return DataCollection(jsPsych.utils.deepCopy(trials));
    }

    data_collection.addToAll = function(properties){
      for (var i = 0; i < trials.length; i++) {
        for (var key in properties) {
          trials[i][key] = properties[key];
        }
      }
      return data_collection;
    }

    data_collection.addToLast = function(properties){
      if(trials.length != 0){
        for (var key in properties) {
          trials[trials.length-1][key] = properties[key];
        }
      }
      return data_collection;
    }

    data_collection.filter = function(filters){
      // [{p1: v1, p2:v2}, {p1:v2}]
      // {p1: v1}
      if(!Array.isArray(filters)){
        var f = jsPsych.utils.deepCopy([filters]);
      } else {
        var f = jsPsych.utils.deepCopy(filters);
      }

      var filtered_data = [];
      for(var x=0; x < trials.length; x++){
        var keep = false;
        for(var i=0; i<f.length; i++){
          var match = true;
          var keys = Object.keys(f[i]);
          for(var k=0; k<keys.length; k++){
            if(typeof trials[x][keys[k]] !== 'undefined' && trials[x][keys[k]] == f[i][keys[k]]){
              // matches on this key!
            } else {
              match = false;
            }
          }
          if(match) { keep = true; break; } // can break because each filter is OR.
        }
        if(keep){
          filtered_data.push(trials[x]);
        }
      }

      var out = DataCollection(filtered_data);

      return out;
    }

    data_collection.filterCustom = function(fn){
      var included = [];
      for(var i=0; i<trials.length; i++){
        if(fn(trials[i])){
          included.push(trials[i]);
        }
      }
      return DataCollection(included);
    }

    data_collection.select = function(column){
      var values = [];
      for(var i=0; i<trials.length; i++){
        if(typeof trials[i][column] !== 'undefined'){
          values.push(trials[i][column]);
        }
      }
      var out = DataColumn();
      out.values = values;
      return out;
    }

    data_collection.ignore = function(columns){
      if(!Array.isArray(columns)){
        columns = [columns];
      }
      var o = jsPsych.utils.deepCopy(trials);
      for (var i = 0; i < o.length; i++) {
        for (var j in columns) {
          delete o[i][columns[j]];
        }
      }
      return DataCollection(o);
    }

    data_collection.uniqueNames = function(){
      var names = [];

      for(var i=0; i<trials.length; i++){
        var keys = Object.keys(trials[i]);
        for(var j=0; j<keys.length; j++){
          if(!names.includes(keys[j])){
            names.push(keys[j]);
          }
        }
      }

      return names;
    }

    data_collection.csv = function(){
      return JSON2CSV(trials);
    }

    data_collection.json = function(pretty){
      if(pretty){
        return JSON.stringify(trials, null, '\t');
      }
      return JSON.stringify(trials);
    }

    data_collection.localSave = function(format, filename){
      var data_string;

      if (format == 'JSON' || format == 'json') {
        data_string = data_collection.json();
      } else if (format == 'CSV' || format == 'csv') {
        data_string = data_collection.csv();
      } else {
        throw new Error('Invalid format specified for localSave. Must be "JSON" or "CSV".');
      }

      saveTextToFile(data_string, filename);
    }

    return data_collection;
  }

  // DataColumn class
  function DataColumn(){
    var data_column = {};

    data_column.values = [];

    data_column.sum = function(){
      var s = 0;
      for(var i=0; i<data_column.values.length; i++){
        s += data_column.values[i];
      }
      return s;
    }

    data_column.mean = function(){
      return data_column.sum() / data_column.count();
    }

    data_column.median = function(){
      if (data_column.values.length == 0) {return undefined};
      var numbers = data_column.values.slice(0).sort(function(a,b){ return a - b; });
      var middle = Math.floor(numbers.length / 2);
      var isEven = numbers.length % 2 === 0;
      return isEven ? (numbers[middle] + numbers[middle - 1]) / 2 : numbers[middle];
    }

    data_column.min = function(){
      return Math.min.apply(null, data_column.values);
    }

    data_column.max = function(){
      return Math.max.apply(null, data_column.values);
    }

    data_column.count = function(){
      return data_column.values.length;
    }

    data_column.variance = function(){
      var mean = data_column.mean();
      var sum_square_error = 0;
      for(var i=0; i<data_column.values.length; i++){
        sum_square_error += Math.pow(data_column.values[i] - mean,2);
      }
      var mse = sum_square_error / (data_column.values.length - 1);
      return mse;
    }

    data_column.sd = function(){
      var mse = data_column.variance();
      var rmse = Math.sqrt(mse);
      return rmse;
    }

    data_column.frequencies = function(){
      var unique = {}
      for(var i=0; i<data_column.values.length; i++){
        var v = data_column.values[i];
        if(typeof unique[v] == 'undefined'){
          unique[v] = 1;
        } else {
          unique[v]++;
        }
      }
      return unique;
    }

    data_column.all = function(eval_fn){
      for(var i=0; i<data_column.values.length; i++){
        if(!eval_fn(data_column.values[i])){
          return false;
        }
      }
      return true;
    }

    data_column.subset = function(eval_fn){
      var out = [];
      for(var i=0; i<data_column.values.length; i++){
        if(eval_fn(data_column.values[i])){
          out.push(data_column.values[i]);
        }
      }
      var o = DataColumn();
      o.values = out;
      return o;
    }

    return data_column;
  }

  module.reset = function(){
    allData = DataCollection();
    interactionData = DataCollection();
  }

  module.get = function() {
    return allData;
  };

  module.getInteractionData = function() {
    return interactionData;
  }

  module.write = function(data_object) {

    var progress = jsPsych.progress();
    var trial = jsPsych.currentTrial();

    //var trial_opt_data = typeof trial.data == 'function' ? trial.data() : trial.data;

    var default_data = {
      'trial_type': trial.type,
      'trial_index': progress.current_trial_global,
      'time_elapsed': jsPsych.totalTime(),
      'internal_node_id': jsPsych.currentTimelineNodeID()
    };

    var ext_data_object = Object.assign({}, data_object, trial.data, default_data, dataProperties);

    allData.push(ext_data_object);
  };

  module.addProperties = function(properties) {

    // first, add the properties to all data that's already stored
    allData.addToAll(properties);

    // now add to list so that it gets appended to all future data
    dataProperties = Object.assign({}, dataProperties, properties);

  };

  module.addDataToLastTrial = function(data) {
    allData.addToLast(data);
  }

  module.getDataByTimelineNode = function(node_id) {
    var data = allData.filterCustom(function(x){
      return x.internal_node_id.slice(0, node_id.length) === node_id;
    });

    return data;
  };

  module.getLastTrialData = function() {
    return allData.top();
  };

  module.getLastTimelineData = function() {
    var lasttrial = module.getLastTrialData();
    var node_id = lasttrial.select('internal_node_id').values[0];
    if (typeof node_id === 'undefined') {
      return DataCollection();
    } else {
      var parent_node_id = node_id.substr(0,node_id.lastIndexOf('-'));
      var lastnodedata = module.getDataByTimelineNode(parent_node_id);
      return lastnodedata;
    }
  }

  module.displayData = function(format) {
    format = (typeof format === 'undefined') ? "json" : format.toLowerCase();
    if (format != "json" && format != "csv") {
      console.log('Invalid format declared for displayData function. Using json as default.');
      format = "json";
    }

    var data_string;

    if (format == 'json') {
      data_string = allData.json(true); // true = pretty print with tabs
    } else {
      data_string = allData.csv();
    }

    var display_element = jsPsych.getDisplayElement();

    display_element.innerHTML = '<pre id="jspsych-data-display"></pre>';

    document.getElementById('jspsych-data-display').textContent = data_string;
  };

  module.urlVariables = function() {
    if(typeof query_string == 'undefined'){
      query_string = getQueryString();
    }
    return query_string;
  }

  module.getURLVariable = function(whichvar){
    if(typeof query_string == 'undefined'){
      query_string = getQueryString();
    }
    return query_string[whichvar];
  }

  module.createInteractionListeners = function(){
    // blur event capture
    window.addEventListener('blur', function(){
      var data = {
        event: 'blur',
        trial: jsPsych.progress().current_trial_global,
        time: jsPsych.totalTime()
      };
      interactionData.push(data);
      jsPsych.initSettings().on_interaction_data_update(data);
    });

    // focus event capture
    window.addEventListener('focus', function(){
      var data = {
        event: 'focus',
        trial: jsPsych.progress().current_trial_global,
        time: jsPsych.totalTime()
      };
      interactionData.push(data);
      jsPsych.initSettings().on_interaction_data_update(data);
    });

    // fullscreen change capture
    function fullscreenchange(){
      var type = (document.isFullScreen || document.webkitIsFullScreen || document.mozIsFullScreen || document.fullscreenElement) ? 'fullscreenenter' : 'fullscreenexit';
      var data = {
        event: type,
        trial: jsPsych.progress().current_trial_global,
        time: jsPsych.totalTime()
      };
      interactionData.push(data);
      jsPsych.initSettings().on_interaction_data_update(data);
    }

    document.addEventListener('fullscreenchange', fullscreenchange);
    document.addEventListener('mozfullscreenchange', fullscreenchange);
    document.addEventListener('webkitfullscreenchange', fullscreenchange);
  }

  // public methods for testing purposes. not recommended for use.
  module._customInsert = function(data){
    allData = DataCollection(data);
  }

  module._fullreset = function(){
    module.reset();
    dataProperties = {};
  }

  // private function to save text file on local drive
  function saveTextToFile(textstr, filename) {
    var blobToSave = new Blob([textstr], {
      type: 'text/plain'
    });
    var blobURL = "";
    if (typeof window.webkitURL !== 'undefined') {
      blobURL = window.webkitURL.createObjectURL(blobToSave);
    } else {
      blobURL = window.URL.createObjectURL(blobToSave);
    }

    var display_element = jsPsych.getDisplayElement();

    display_element.insertAdjacentHTML('beforeend','<a id="jspsych-download-as-text-link" style="display:none;" download="'+filename+'" href="'+blobURL+'">click to download</a>');
    document.getElementById('jspsych-download-as-text-link').click();
  }

  //
  // A few helper functions to handle data format conversion
  //

  // this function based on code suggested by StackOverflow users:
  // http://stackoverflow.com/users/64741/zachary
  // http://stackoverflow.com/users/317/joseph-sturtevant

  function JSON2CSV(objArray) {
    var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
    var line = '';
    var result = '';
    var columns = [];

    var i = 0;
    for (var j = 0; j < array.length; j++) {
      for (var key in array[j]) {
        var keyString = key + "";
        keyString = '"' + keyString.replace(/"/g, '""') + '",';
        if (!columns.includes(key)) {
          columns[i] = key;
          line += keyString;
          i++;
        }
      }
    }

    line = line.slice(0, -1);
    result += line + '\r\n';

    for (var i = 0; i < array.length; i++) {
      var line = '';
      for (var j = 0; j < columns.length; j++) {
        var value = (typeof array[i][columns[j]] === 'undefined') ? '' : array[i][columns[j]];
        if(typeof value == 'object') {
          value = JSON.stringify(value);
        }
        var valueString = value + "";
        line += '"' + valueString.replace(/"/g, '""') + '",';
      }

      line = line.slice(0, -1);
      result += line + '\r\n';
    }

    return result;
  }

  // this function is modified from StackOverflow:
  // http://stackoverflow.com/posts/3855394

  function getQueryString() {
    var a = window.location.search.substr(1).split('&');
    if (a == "") return {};
    var b = {};
    for (var i = 0; i < a.length; ++i)
    {
        var p=a[i].split('=', 2);
        if (p.length == 1)
            b[p[0]] = "";
        else
            b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
    }
    return b;
  }

  return module;

})();

jsPsych.turk = (function() {

  var module = {};

  // core.turkInfo gets information relevant to mechanical turk experiments. returns an object
  // containing the workerID, assignmentID, and hitID, and whether or not the HIT is in
  // preview mode, meaning that they haven't accepted the HIT yet.
  module.turkInfo = function() {

    var turk = {};

    var param = function(url, name) {
      name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
      var regexS = "[\\?&]" + name + "=([^&#]*)";
      var regex = new RegExp(regexS);
      var results = regex.exec(url);
      return (results == null) ? "" : results[1];
    };

    var src = param(window.location.href, "assignmentId") ? window.location.href : document.referrer;

    var keys = ["assignmentId", "hitId", "workerId", "turkSubmitTo"];
    keys.map(

      function(key) {
        turk[key] = unescape(param(src, key));
      });

    turk.previewMode = (turk.assignmentId == "ASSIGNMENT_ID_NOT_AVAILABLE");

    turk.outsideTurk = (!turk.previewMode && turk.hitId === "" && turk.assignmentId == "" && turk.workerId == "")

    turk_info = turk;

    return turk;

  };

  // core.submitToTurk will submit a MechanicalTurk ExternalHIT type
  module.submitToTurk = function(data) {

    var turkInfo = jsPsych.turk.turkInfo();
    var assignmentId = turkInfo.assignmentId;
    var turkSubmitTo = turkInfo.turkSubmitTo;

    if (!assignmentId || !turkSubmitTo) return;

    var dataString = [];

    for (var key in data) {

      if (data.hasOwnProperty(key)) {
        dataString.push(key + "=" + escape(data[key]));
      }
    }

    dataString.push("assignmentId=" + assignmentId);

    var url = turkSubmitTo + "/mturk/externalSubmit?" + dataString.join("&");

    window.location.href = url;
  };

  return module;

})();

jsPsych.randomization = (function() {

  var module = {};

  module.repeat = function(array, repetitions, unpack) {

    var arr_isArray = Array.isArray(array);
    var rep_isArray = Array.isArray(repetitions);

    // if array is not an array, then we just repeat the item
    if (!arr_isArray) {
      if (!rep_isArray) {
        array = [array];
        repetitions = [repetitions];
      } else {
        repetitions = [repetitions[0]];
        console.log('Unclear parameters given to randomization.repeat. Multiple set sizes specified, but only one item exists to sample. Proceeding using the first set size.');
      }
    } else {
      if (!rep_isArray) {
        var reps = [];
        for (var i = 0; i < array.length; i++) {
          reps.push(repetitions);
        }
        repetitions = reps;
      } else {
        if (array.length != repetitions.length) {
          console.warning('Unclear parameters given to randomization.repeat. Items and repetitions are unequal lengths. Behavior may not be as expected.');
          // throw warning if repetitions is too short, use first rep ONLY.
          if (repetitions.length < array.length) {
            var reps = [];
            for (var i = 0; i < array.length; i++) {
              reps.push(repetitions);
            }
            repetitions = reps;
          } else {
            // throw warning if too long, and then use the first N
            repetitions = repetitions.slice(0, array.length);
          }
        }
      }
    }

    // should be clear at this point to assume that array and repetitions are arrays with == length
    var allsamples = [];
    for (var i = 0; i < array.length; i++) {
      for (var j = 0; j < repetitions[i]; j++) {
        if(array[i] == null || typeof array[i] != 'object'){
          allsamples.push(array[i]);
        } else {
          allsamples.push(Object.assign({}, array[i]));
        }

      }
    }

    var out = shuffle(allsamples);

    if (unpack) {
      out = unpackArray(out);
    }

    return out;
  }

  module.shuffle = function(arr) {
    if(!Array.isArray(arr)){
      console.error('Argument to jsPsych.randomization.shuffle() must be an array.')
    }
    return shuffle(arr);
  }

  module.shuffleNoRepeats = function(arr, equalityTest) {
    if(!Array.isArray(arr)){
      console.error('First argument to jsPsych.randomization.shuffleNoRepeats() must be an array.')
    }
    if(typeof equalityTest !== 'undefined' && typeof equalityTest !== 'function'){
      console.error('Second argument to jsPsych.randomization.shuffleNoRepeats() must be a function.')
    }
    // define a default equalityTest
    if (typeof equalityTest == 'undefined') {
      equalityTest = function(a, b) {
        if (a === b) {
          return true;
        } else {
          return false;
        }
      }
    }

    var random_shuffle = shuffle(arr);
    for (var i = 0; i < random_shuffle.length - 1; i++) {
      if (equalityTest(random_shuffle[i], random_shuffle[i + 1])) {
        // neighbors are equal, pick a new random neighbor to swap (not the first or last element, to avoid edge cases)
        var random_pick = Math.floor(Math.random() * (random_shuffle.length - 2)) + 1;
        // test to make sure the new neighbor isn't equal to the old one
        while (
          equalityTest(random_shuffle[i + 1], random_shuffle[random_pick]) ||
          (equalityTest(random_shuffle[i + 1], random_shuffle[random_pick + 1]) || equalityTest(random_shuffle[i + 1], random_shuffle[random_pick - 1]))
        ) {
          random_pick = Math.floor(Math.random() * (random_shuffle.length - 2)) + 1;
        }
        var new_neighbor = random_shuffle[random_pick];
        random_shuffle[random_pick] = random_shuffle[i + 1];
        random_shuffle[i + 1] = new_neighbor;
      }
    }

    return random_shuffle;
  }

  module.shuffleAlternateGroups = function(arr_groups, random_group_order){
    if(typeof random_group_order == 'undefined'){
      random_group_order = false;
    }

    var n_groups = arr_groups.length;
    if(n_groups == 1){
      console.warn('jsPsych.randomization.shuffleAlternateGroups was called with only one group. Defaulting to simple shuffle.');
      return(module.shuffle(arr_groups[0]));
    }

    var group_order = [];
    for(var i=0; i<n_groups; i++){
      group_order.push(i);
    }
    if(random_group_order){
      group_order = module.shuffle(group_order);
    }

    var randomized_groups = [];
    var min_length = null;
    for(var i=0; i<n_groups; i++){
      min_length = min_length === null ? arr_groups[i].length : Math.min(min_length, arr_groups[i].length);
      randomized_groups.push(module.shuffle(arr_groups[i]));
    }

    var out = [];
    for(var i=0; i<min_length; i++){
      for(var j=0; j<group_order.length; j++){
        out.push(randomized_groups[group_order[j]][i])
      }
    }

    return out;
  }

  module.sampleWithoutReplacement = function(arr, size){
    if(!Array.isArray(arr)){
      console.error("First argument to jsPsych.randomization.sampleWithoutReplacement() must be an array")
    }
    
    if (size > arr.length) {
      console.error("Cannot take a sample " +
        "larger than the size of the set of items to sample.");
    }
    return jsPsych.randomization.shuffle(arr).slice(0,size);
  }

  module.sampleWithReplacement = function(arr, size, weights) {
    if(!Array.isArray(arr)){
      console.error("First argument to jsPsych.randomization.sampleWithReplacement() must be an array")
    }

    var normalized_weights = [];
    if(typeof weights !== 'undefined'){
      if(weights.length !== arr.length){
        console.error('The length of the weights array must equal the length of the array '+
        'to be sampled from.');
      }
      var weight_sum = 0;
      for(var i=0; i<weights.length; i++){
        weight_sum += weights[i];
      }
      for(var i=0; i<weights.length; i++){
        normalized_weights.push( weights[i] / weight_sum );
      }
    } else {
      for(var i=0; i<arr.length; i++){
        normalized_weights.push( 1 / arr.length );
      }
    }

    var cumulative_weights = [normalized_weights[0]];
    for(var i=1; i<normalized_weights.length; i++){
      cumulative_weights.push(normalized_weights[i] + cumulative_weights[i-1]);
    }

    var samp = [];
    for (var i = 0; i < size; i++) {
      var rnd = Math.random();
      var index = 0;
      while(rnd > cumulative_weights[index]) { index++; }
      samp.push(arr[index]);
    }
    return samp;
  }

  module.factorial = function(factors, repetitions, unpack) {

    var factorNames = Object.keys(factors);

    var factor_combinations = [];

    for (var i = 0; i < factors[factorNames[0]].length; i++) {
      factor_combinations.push({});
      factor_combinations[i][factorNames[0]] = factors[factorNames[0]][i];
    }

    for (var i = 1; i < factorNames.length; i++) {
      var toAdd = factors[factorNames[i]];
      var n = factor_combinations.length;
      for (var j = 0; j < n; j++) {
        var base = factor_combinations[j];
        for (var k = 0; k < toAdd.length; k++) {
          var newpiece = {};
          newpiece[factorNames[i]] = toAdd[k];
          factor_combinations.push(Object.assign({}, base, newpiece));
        }
      }
      factor_combinations.splice(0, n);
    }

    repetitions = (typeof repetitions === 'undefined') ? 1 : repetitions;
    var with_repetitions = module.repeat(factor_combinations, repetitions, unpack);

    return with_repetitions;
  }

  module.randomID = function(length){
    var result = '';
    var length = (typeof length == 'undefined') ? 32 : length;
    var chars = '0123456789abcdefghjklmnopqrstuvwxyz';
    for(var i = 0; i<length; i++){
      result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
  }

  function unpackArray(array) {

    var out = {};

    for (var i = 0; i < array.length; i++) {
      var keys = Object.keys(array[i]);
      for (var k = 0; k < keys.length; k++) {
        if (typeof out[keys[k]] === 'undefined') {
          out[keys[k]] = [];
        }
        out[keys[k]].push(array[i][keys[k]]);
      }
    }

    return out;
  }

  function shuffle(array) {
    var copy_array = array.slice(0);
    var m = copy_array.length,
      t, i;

    // While there remain elements to shuffle…
    while (m) {

      // Pick a remaining element…
      i = Math.floor(Math.random() * m--);

      // And swap it with the current element.
      t = copy_array[m];
      copy_array[m] = copy_array[i];
      copy_array[i] = t;
    }

    return copy_array;
  }

  return module;

})();

jsPsych.pluginAPI = (function() {

  var module = {};

  // keyboard listeners //

  var keyboard_listeners = [];

  var held_keys = {};

  var root_keydown_listener = function(e){
    for(var i=0; i<keyboard_listeners.length; i++){
      keyboard_listeners[i].fn(e);
    }
    held_keys[e.key] = true;
  }
  var root_keyup_listener = function(e){
    held_keys[e.key] = false;
  }

  module.reset = function(root_element){
    keyboard_listeners = [];
    held_keys = {};
    root_element.removeEventListener('keydown', root_keydown_listener);
    root_element.removeEventListener('keyup', root_keyup_listener);
  }

  module.createKeyboardEventListeners = function(root_element){
    root_element.addEventListener('keydown', root_keydown_listener);
    root_element.addEventListener('keyup', root_keyup_listener);
  }

  module.getKeyboardResponse = function(parameters) {

    //parameters are: callback_function, valid_responses, rt_method, persist, audio_context, audio_context_start_time, allow_held_key

    parameters.rt_method = (typeof parameters.rt_method === 'undefined') ? 'performance' : parameters.rt_method;
    if (parameters.rt_method != 'performance' && parameters.rt_method != 'audio') {
      console.log('Invalid RT method specified in getKeyboardResponse. Defaulting to "performance" method.');
      parameters.rt_method = 'performance';
    }

    var start_time;
    if (parameters.rt_method == 'performance') {
      start_time = performance.now();
    } else if (parameters.rt_method === 'audio') {
      start_time = parameters.audio_context_start_time;
    }

    var case_sensitive = (typeof jsPsych.initSettings().case_sensitive_responses === 'undefined') ? false : jsPsych.initSettings().case_sensitive_responses;

    var listener_id;

    var listener_function = function(e) {
      var key_time;
      if (parameters.rt_method == 'performance') {
        key_time = performance.now();
      } else if (parameters.rt_method === 'audio') {
        key_time = parameters.audio_context.currentTime
      }
      var rt = key_time - start_time;

      // overiding via parameters for testing purposes.
      var minimum_valid_rt = parameters.minimum_valid_rt;
      if(!minimum_valid_rt){
        minimum_valid_rt = jsPsych.initSettings().minimum_valid_rt || 0;
      }

      if(rt < minimum_valid_rt){
        return;
      }

      var valid_response = false;
      if (typeof parameters.valid_responses === 'undefined'){
        valid_response = true;
      }
      else if(parameters.valid_responses == jsPsych.ALL_KEYS) {
        valid_response = true;
      } 
      else if(parameters.valid_responses != jsPsych.NO_KEYS){
        if(parameters.valid_responses.includes(e.key)){
          valid_response = true;
        }
        if(!case_sensitive) {
          var valid_lower = parameters.valid_responses.map(function(v) {return v.toLowerCase();});
          var key_lower = e.key.toLowerCase();
          if (valid_lower.includes(key_lower)) {
            valid_response = true;
          }
        }
      }
      
      // check if key was already held down
      if (((typeof parameters.allow_held_key === 'undefined') || !parameters.allow_held_key) && valid_response) {
        if (typeof held_keys[e.key] !== 'undefined' && held_keys[e.key] == true) {
          valid_response = false;
        }
        if (!case_sensitive && typeof held_keys[e.key.toLowerCase()] !== 'undefined' && held_keys[e.key.toLowerCase()] == true) {
          valid_response = false;
        }
      }

      if (valid_response) {
        // if this is a valid response, then we don't want the key event to trigger other actions
        // like scrolling via the spacebar.
        e.preventDefault();
        var key = e.key;
        if (!case_sensitive) {
          key = key.toLowerCase();
        }
        parameters.callback_function({
          key: key,
          rt: rt,
        });

        if (keyboard_listeners.includes(listener_id)) {

          if (!parameters.persist) {
            // remove keyboard listener
            module.cancelKeyboardResponse(listener_id);
          }
        }
      }
    };

    // create listener id object
    listener_id = {
      type: 'keydown',
      fn: listener_function
    };

    // add this keyboard listener to the list of listeners
    keyboard_listeners.push(listener_id);

    return listener_id;

  };

  module.cancelKeyboardResponse = function(listener) {
    // remove the listener from the list of listeners
    if (keyboard_listeners.includes(listener)) {
      keyboard_listeners.splice(keyboard_listeners.indexOf(listener), 1);
    }
  };

  module.cancelAllKeyboardResponses = function() {
    keyboard_listeners = [];
  };

  module.convertKeyCharacterToKeyCode = function(character) {
    console.warn('Warning: The jsPsych.pluginAPI.convertKeyCharacterToKeyCode function will be removed in future jsPsych releases. '+
    'We recommend removing this function and using strings to identify/compare keys.');
    var code;
    character = character.toLowerCase();
    if (typeof keylookup[character] !== 'undefined') {
      code = keylookup[character];
    }
    return code;
  }

  module.convertKeyCodeToKeyCharacter = function(code){
    console.warn('Warning: The jsPsych.pluginAPI.convertKeyCodeToKeyCharacter function will be removed in future jsPsych releases. '+
    'We recommend removing this function and using strings to identify/compare keys.');
    for(var i in Object.keys(keylookup)){
      if(keylookup[Object.keys(keylookup)[i]] == code){
        return Object.keys(keylookup)[i];
      }
    }
    return undefined;
  }

  module.compareKeys = function(key1, key2){
    if (Number.isFinite(key1) || Number.isFinite(key2)) {
      // if either value is a numeric keyCode, then convert both to numeric keyCode values and compare (maintained for backwards compatibility)
      if(typeof key1 == 'string') {
        key1 = module.convertKeyCharacterToKeyCode(key1);
      }
      if(typeof key2 == 'string') {
        key2 = module.convertKeyCharacterToKeyCode(key2);
      }
      return key1 == key2;
    } else if (typeof key1 === 'string' && typeof key2 === 'string') {
      // if both values are strings, then check whether or not letter case should be converted before comparing (case_sensitive_responses in jsPsych.init)
      var case_sensitive = (typeof jsPsych.initSettings().case_sensitive_responses === 'undefined') ? false : jsPsych.initSettings().case_sensitive_responses;
      if (case_sensitive) {
        return key1 == key2;
      } else {
        return key1.toLowerCase() == key2.toLowerCase();
      }
    } else {
      console.error('Error in jsPsych.pluginAPI.compareKeys: arguments must be either numeric key codes or key strings.');
      return undefined;
    }
  }

  var keylookup = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'pause': 19,
    'capslock': 20,
    'esc': 27,
    'space': 32,
    'spacebar': 32,
    ' ': 32,
    'pageup': 33,
    'pagedown': 34,
    'end': 35,
    'home': 36,
    'leftarrow': 37,
    'uparrow': 38,
    'rightarrow': 39,
    'downarrow': 40,
    'insert': 45,
    'delete': 46,
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    'a': 65,
    'b': 66,
    'c': 67,
    'd': 68,
    'e': 69,
    'f': 70,
    'g': 71,
    'h': 72,
    'i': 73,
    'j': 74,
    'k': 75,
    'l': 76,
    'm': 77,
    'n': 78,
    'o': 79,
    'p': 80,
    'q': 81,
    'r': 82,
    's': 83,
    't': 84,
    'u': 85,
    'v': 86,
    'w': 87,
    'x': 88,
    'y': 89,
    'z': 90,
    '0numpad': 96,
    '1numpad': 97,
    '2numpad': 98,
    '3numpad': 99,
    '4numpad': 100,
    '5numpad': 101,
    '6numpad': 102,
    '7numpad': 103,
    '8numpad': 104,
    '9numpad': 105,
    'multiply': 106,
    'plus': 107,
    'minus': 109,
    'decimal': 110,
    'divide': 111,
    'f1': 112,
    'f2': 113,
    'f3': 114,
    'f4': 115,
    'f5': 116,
    'f6': 117,
    'f7': 118,
    'f8': 119,
    'f9': 120,
    'f10': 121,
    'f11': 122,
    'f12': 123,
    '=': 187,
    ',': 188,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221
  };

  // timeout registration

  var timeout_handlers = [];

  module.setTimeout = function(callback, delay){
    var handle = setTimeout(callback, delay);
    timeout_handlers.push(handle);
    return handle;
  }

  module.clearAllTimeouts = function(){
    for(var i=0;i<timeout_handlers.length; i++){
      clearTimeout(timeout_handlers[i]);
    }
    timeout_handlers = [];
  }

  // video //
    var video_buffers = {}
    module.getVideoBuffer = function(videoID) {
      return video_buffers[videoID]
    }

  // audio //
  var context = null;
  var audio_buffers = [];

  module.initAudio = function(){
    context = (jsPsych.initSettings().use_webaudio === true) ? jsPsych.webaudio_context : null;
  }

  module.audioContext = function(){
    if(context !== null){
      if(context.state !== 'running'){
        context.resume();
      }
    }
    return context;
  }

  module.getAudioBuffer = function(audioID) {

    return new Promise(function(resolve, reject){
      // check whether audio file already preloaded
      if(typeof audio_buffers[audioID] == 'undefined' || audio_buffers[audioID] == 'tmp'){
         // if audio is not already loaded, try to load it
        function complete(){
          resolve(audio_buffers[audioID])
        }
        function error(e){
          reject(e.error);
        }
        module.preloadAudio([audioID], complete, function(){}, error)
      } else {
        // audio is already loaded
        resolve(audio_buffers[audioID]);
      }
    });

  }

  // preloading stimuli //

  var preloads = [];
  var preload_requests = [];

  var img_cache = {};

  module.preloadAudio = function(files, callback_complete, callback_load, callback_error) {

    files = jsPsych.utils.flatten(files);
    files = jsPsych.utils.unique(files);

    var n_loaded = 0;
    var loadfn = (typeof callback_load === 'undefined') ? function() {} : callback_load;
    var finishfn = (typeof callback_complete === 'undefined') ? function() {} : callback_complete;
    var errorfn = (typeof callback_error === 'undefined') ? function() {} : callback_error;

    if(files.length==0){
      finishfn();
      return;
    }

    function load_audio_file_webaudio(source, count){
      count = count || 1;
      var request = new XMLHttpRequest();
      request.open('GET', source, true);
      request.responseType = 'arraybuffer';
      request.onload = function() {
        context.decodeAudioData(request.response, function(buffer) {
          audio_buffers[source] = buffer;
          n_loaded++;
          loadfn(source);
          if(n_loaded == files.length) {
            finishfn();
          }
        }, function(e) {
          errorfn({source: source, error: e});
        });
      }
      request.onerror = function(e){
        var err = e;
        if(this.status == 404) {
          err = "404";
        }
        errorfn({source: source, error: err});
      }
      request.onloadend = function(e){
        if(this.status == 404) {
          errorfn({source: source, error: "404"});
        }
      }
      request.send();
      preload_requests.push(request);
    }

    function load_audio_file_html5audio(source, count){
      count = count || 1;
      var audio = new Audio();
      audio.addEventListener('canplaythrough', function handleCanPlayThrough(){
        audio_buffers[source] = audio;
        n_loaded++;
        loadfn(source);
        if(n_loaded == files.length){
          finishfn();
        }
        audio.removeEventListener('canplaythrough', handleCanPlayThrough);
      });
      audio.addEventListener('error', function handleError(e){
        errorfn({source: audio.src, error: e});
        audio.removeEventListener('error', handleError);
      });
      audio.addEventListener('abort', function handleAbort(e){
        errorfn({source: audio.src, error: e});
        audio.removeEventListener('abort', handleAbort);
      });
      audio.src = source;
      preload_requests.push(audio);
    }

    for (var i = 0; i < files.length; i++) {
      var bufferID = files[i];
      if (typeof audio_buffers[bufferID] !== 'undefined') {
        n_loaded++;
        loadfn(bufferID);
        if(n_loaded == files.length) {
          finishfn();
        }
      } else {
        audio_buffers[bufferID] = 'tmp';
        if(module.audioContext() !== null){
          load_audio_file_webaudio(bufferID);
        } else {
          load_audio_file_html5audio(bufferID);
        }
      }
    }

  }

  module.preloadImages = function(images, callback_complete, callback_load, callback_error) {

    // flatten the images array
    images = jsPsych.utils.flatten(images);
    images = jsPsych.utils.unique(images);

    var n_loaded = 0;
    var finishfn = (typeof callback_complete === 'undefined') ? function() {} : callback_complete;
    var loadfn = (typeof callback_load === 'undefined') ? function() {} : callback_load;
    var errorfn = (typeof callback_error === 'undefined') ? function() {} : callback_error;

    if(images.length === 0){
      finishfn();
      return;
    }

    function preload_image(source){
      var img = new Image();

      img.onload = function() {
        n_loaded++;
        loadfn(img.src);
        if (n_loaded === images.length) {
          finishfn();
        }
      };

      img.onerror = function(e) {
        errorfn({source: img.src, error: e});
      }

      img.src = source;

      img_cache[source] = img;
      preload_requests.push(img);
    }

    for (var i = 0; i < images.length; i++) {
      preload_image(images[i]);
    }

  };

  module.preloadVideo = function(video, callback_complete, callback_load, callback_error) {

      // flatten the video array
      video = jsPsych.utils.flatten(video);
      video = jsPsych.utils.unique(video);

      var n_loaded = 0;
      var finishfn = !callback_complete ? function() {} : callback_complete;
      var loadfn = !callback_load ? function() {} : callback_load;
      var errorfn = (typeof callback_error === 'undefined') ? function() {} : callback_error;

      if(video.length===0){
          finishfn();
          return;
      }

      function preload_video(source, count){
        count = count || 1;
        //based on option 4 here: http://dinbror.dk/blog/how-to-preload-entire-html5-video-before-play-solved/
        var request = new XMLHttpRequest();
        request.open('GET', source, true);
        request.responseType = 'blob';
        request.onload = function() {
          if (this.status === 200 || this.status === 0) {
            var videoBlob = this.response;
            video_buffers[source] = URL.createObjectURL(videoBlob); // IE10+
            n_loaded++;
            loadfn(source);
            if (n_loaded === video.length) {
              finishfn();
            }
          }
        };
        request.onerror = function(e){
          var err = e;
          if(this.status == 404) {
            err = "404";
          }
          errorfn({source: source, error: err});
        }
        request.onloadend = function(e){
          if(this.status == 404) {
            errorfn({source: source, error: "404"});
          }
        }
        request.send();
        preload_requests.push(request);
      }

      for (var i = 0; i < video.length; i++) {
        preload_video(video[i]);
      }

  };

  module.registerPreload = function(plugin_name, parameter, media_type) {
    if (['audio', 'image', 'video'].indexOf(media_type)===-1) {
      console.error('Invalid media_type parameter for jsPsych.pluginAPI.registerPreload. Please check the plugin file.');
    }

    var preload = {
      plugin: plugin_name,
      parameter: parameter,
      media_type: media_type
    }

    preloads.push(preload);
  }

  module.getAutoPreloadList = function(timeline_description){

    function getTrialsOfTypeFromTimelineDescription(td, target_type, inherited_type){
      var trials = [];

      for(var i=0; i<td.length; i++){
        var node = td[i];
        if(Array.isArray(node.timeline)){
          if(typeof node.type !== 'undefined'){
            inherited_type = node.type;
          }
          trials = trials.concat(getTrialsOfTypeFromTimelineDescription(node.timeline, target_type, inherited_type));
        } else {
          if(typeof node.type !== 'undefined' && node.type == target_type){
            trials.push(node);
          }
          if(typeof node.type == 'undefined' && inherited_type == target_type){
            trials.push(Object.assign({}, {type: target_type}, node));
          }
        }
      }

      return trials;
    }

    if(typeof timeline_description == 'undefined'){
      timeline_description = jsPsych.initSettings().timeline;
    }

    // list of items to preload
    var images = [];
    var audio = [];
    var video = [];

    // construct list
    for (var i = 0; i < preloads.length; i++) {
      var type = preloads[i].plugin;
      var param = preloads[i].parameter;
      var media = preloads[i].media_type;

      var trials = getTrialsOfTypeFromTimelineDescription(timeline_description, type);
      for (var j = 0; j < trials.length; j++) {

        if (typeof trials[j][param] == 'undefined') {
          console.warn("jsPsych failed to auto preload one or more files:");
          console.warn("no parameter called "+param+" in plugin "+type);
        } else if (typeof trials[j][param] !== 'function') {
          if (media === 'image') {
            images = images.concat(jsPsych.utils.flatten([trials[j][param]]));
          } else if (media === 'audio') {
            audio = audio.concat(jsPsych.utils.flatten([trials[j][param]]));
          } else if (media === 'video') {
            video = video.concat(jsPsych.utils.flatten([trials[j][param]]));
          }
        }
      }
    }

    images = jsPsych.utils.unique(jsPsych.utils.flatten(images));
    audio  = jsPsych.utils.unique(jsPsych.utils.flatten(audio));
    video  = jsPsych.utils.unique(jsPsych.utils.flatten(video));

    // remove any nulls false values
    images = images.filter(function(x) { return x != false && x != null})
    audio = audio.filter(function(x) { return x != false && x != null})
    video = video.filter(function(x) { return x != false && x != null})

    return {
      images, audio, video
    }
  }

  module.cancelPreloads = function() {
    for(var i=0;i<preload_requests.length; i++){
      preload_requests[i].onload = function() {};
      preload_requests[i].onerror = function() {};
      preload_requests[i].oncanplaythrough = function() {};
      preload_requests[i].onabort = function() {};
    }
    preload_requests = [];
  }

  /**
   * Allows communication with user hardware through our custom Google Chrome extension + native C++ program
   * @param		{object}	mess	The message to be passed to our extension, see its documentation for the expected members of this object.
   * @author	Daniel Rivas
   *
   */
  module.hardware = function hardware(mess){
	  //since Chrome extension content-scripts do not share the javascript environment with the page script that loaded jspsych,
	  //we will need to use hacky methods like communicating through DOM events.
	  var jspsychEvt = new CustomEvent('jspsych', {detail: mess});
	  document.dispatchEvent(jspsychEvt);
	  //And voila! it will be the job of the content script injected by the extension to listen for the event and do the appropriate actions.
  };

  /** {boolean} Indicates whether this instance of jspsych has opened a hardware connection through our browser extension */
  module.hardwareConnected = false;


  //it might be useful to open up a line of communication from the extension back to this page script,
  //again, this will have to pass through DOM events. For now speed is of no concern so I will use jQuery
  document.addEventListener("jspsych-activate", function(evt){
	  module.hardwareConnected = true;
  })



  return module;
})();

// methods used in multiple modules //
jsPsych.utils = (function() {

	var module = {};

	module.flatten = function(arr, out) {
		out = (typeof out === 'undefined') ? [] : out;
		for (var i = 0; i < arr.length; i++) {
			if (Array.isArray(arr[i])) {
				module.flatten(arr[i], out);
			} else {
				out.push(arr[i]);
			}
		}
		return out;
	}

	module.unique = function(arr) {
		var out = [];
		for (var i = 0; i < arr.length; i++) {
			if (arr.indexOf(arr[i]) == i) {
				out.push(arr[i]);
			}
		}
		return out;
	}

	module.deepCopy = function(obj) {
    if(!obj) return obj;
    var out;
    if(Array.isArray(obj)){
      out = [];
      for(var i = 0; i<obj.length; i++){
        out.push(module.deepCopy(obj[i]));
      }
      return out;
    } else if(typeof obj === 'object'){
      out = {};
      for(var key in obj){
        if(obj.hasOwnProperty(key)){
          out[key] = module.deepCopy(obj[key]);
        }
      }
      return out;
    } else {
      return obj;
    }
  }

	return module;
})();

// polyfill for Object.assign to support IE
if (typeof Object.assign != 'function') {
  Object.assign = function (target, varArgs) { // .length of function is 2
    'use strict';
    if (target == null) { // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];

      if (nextSource != null) { // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

// polyfill for Array.includes to support IE
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement /*, fromIndex*/) {
    'use strict';
    if (this == null) {
      throw new TypeError('Array.prototype.includes called on null or undefined');
    }

    var O = Object(this);
    var len = parseInt(O.length, 10) || 0;
    if (len === 0) {
      return false;
    }
    var n = parseInt(arguments[1], 10) || 0;
    var k;
    if (n >= 0) {
      k = n;
    } else {
      k = len + n;
      if (k < 0) {k = 0;}
    }
    var currentElement;
    while (k < len) {
      currentElement = O[k];
      if (searchElement === currentElement ||
         (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN
        return true;
      }
      k++;
    }
    return false;
  };
}

// polyfill for Array.isArray
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
</script>
<script>/**
 * jspsych-html-keyboard-response
 * Josh de Leeuw
 *
 * plugin for displaying a stimulus and getting a keyboard response
 *
 * documentation: docs.jspsych.org
 *
 **/


jsPsych.plugins["html-keyboard-response"] = (function() {

  var plugin = {};

  plugin.info = {
    name: 'html-keyboard-response',
    description: '',
    parameters: {
      stimulus: {
        type: jsPsych.plugins.parameterType.HTML_STRING,
        pretty_name: 'Stimulus',
        default: undefined,
        description: 'The HTML string to be displayed'
      },
      choices: {
        type: jsPsych.plugins.parameterType.KEY,
        array: true,
        pretty_name: 'Choices',
        default: jsPsych.ALL_KEYS,
        description: 'The keys the subject is allowed to press to respond to the stimulus.'
      },
      prompt: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Prompt',
        default: null,
        description: 'Any content here will be displayed below the stimulus.'
      },
      stimulus_duration: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Stimulus duration',
        default: null,
        description: 'How long to hide the stimulus.'
      },
      trial_duration: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Trial duration',
        default: null,
        description: 'How long to show trial before it ends.'
      },
      response_ends_trial: {
        type: jsPsych.plugins.parameterType.BOOL,
        pretty_name: 'Response ends trial',
        default: true,
        description: 'If true, trial will end when subject makes a response.'
      },

    }
  }

  plugin.trial = function(display_element, trial) {

    var new_html = '<div id="jspsych-html-keyboard-response-stimulus">'+trial.stimulus+'</div>';

    // add prompt
    if(trial.prompt !== null){
      new_html += trial.prompt;
    }

    // draw
    display_element.innerHTML = new_html;

    // store response
    var response = {
      rt: null,
      key: null
    };

    // function to end trial when it is time
    var end_trial = function() {

      // kill any remaining setTimeout handlers
      jsPsych.pluginAPI.clearAllTimeouts();

      // kill keyboard listeners
      if (typeof keyboardListener !== 'undefined') {
        jsPsych.pluginAPI.cancelKeyboardResponse(keyboardListener);
      }

      // gather the data to store for the trial
      var trial_data = {
        rt: response.rt,
        stimulus: trial.stimulus,
        response: response.key
      };

      // clear the display
      display_element.innerHTML = '';

      // move on to the next trial
      jsPsych.finishTrial(trial_data);
    };

    // function to handle responses by the subject
    var after_response = function(info) {

      // after a valid response, the stimulus will have the CSS class 'responded'
      // which can be used to provide visual feedback that a response was recorded
      display_element.querySelector('#jspsych-html-keyboard-response-stimulus').className += ' responded';

      // only record the first response
      if (response.key == null) {
        response = info;
      }

      if (trial.response_ends_trial) {
        end_trial();
      }
    };

    // start the response listener
    if (trial.choices != jsPsych.NO_KEYS) {
      var keyboardListener = jsPsych.pluginAPI.getKeyboardResponse({
        callback_function: after_response,
        valid_responses: trial.choices,
        rt_method: 'performance',
        persist: false,
        allow_held_key: false
      });
    }

    // hide stimulus if stimulus_duration is set
    if (trial.stimulus_duration !== null) {
      jsPsych.pluginAPI.setTimeout(function() {
        display_element.querySelector('#jspsych-html-keyboard-response-stimulus').style.visibility = 'hidden';
      }, trial.stimulus_duration);
    }

    // end trial if trial_duration is set
    if (trial.trial_duration !== null) {
      jsPsych.pluginAPI.setTimeout(function() {
        end_trial();
      }, trial.trial_duration);
    }

  };

  return plugin;
})();
</script>
<script>/**
 * jspsych-psychophysics
 * Copyright (c) 2019 Daiichiro Kuroki
 * Released under the MIT license
 * 
 * jspsych-psychophysics is a plugin for conducting online/Web-based psychophysical experiments using jsPsych (de Leeuw, 2015). 
 *
 * Please see 
 * http://jspsychophysics.hes.kyushu-u.ac.jp/
 * about how to use this plugin.
 *
 **/

 /* global jsPsych, math, numeric */

jsPsych.plugins["psychophysics"] = (function() {
  console.log(`jsPsych Version ${jsPsych.version()}`)
  console.log('jspsych-psychophysics Version 2.3.1')

  let plugin = {};

  plugin.info = {
    name: 'psychophysics',
    description: 'A plugin for conducting online/Web-based psychophysical experiments',
    parameters: {
      stimuli: {
        type: jsPsych.plugins.parameterType.COMPLEX, // This is similar to the quesions of the survey-likert. 
        array: true,
        pretty_name: 'Stimuli',
        description: 'The objects will be presented in the canvas.',
        nested: {
          startX: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'startX',
            default: 'center',
            description: 'The horizontal start position.'
          },
          startY: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'startY',
            default: 'center',
            description: 'The vertical start position.'
          },
          endX: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'endX',
            default: null,
            description: 'The horizontal end position.'
          },
          endY: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'endY',
            default: null,
            description: 'The vertical end position.'
          },
          show_start_time: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'Show start time',
            default: 0,
            description: 'Time to start presenting the stimuli'
          },
          show_end_time: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'Show end time',
            default: null,
            description: 'Time to end presenting the stimuli'
          },
          show_start_frame: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'Show start frame',
            default: 0,
            description: 'Time to start presenting the stimuli in frames'
          },
          show_end_frame: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'Show end frame',
            default: null,
            description: 'Time to end presenting the stimuli in frames'
          },
          line_width: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'Line width',
            default: 1,
            description: 'The line width'
          },
          lineJoin: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'lineJoin',
            default: 'miter',
            description: 'The type of the corner when two lines meet.'
          },
          miterLimit: {
            type: jsPsych.plugins.parameterType.INT,
            pretty_name: 'miterLimit',
            default: 10,
            description: 'The maximum miter length.'
          },
          drawFunc: {
            type: jsPsych.plugins.parameterType.FUNCTION,
            pretty_name: 'Draw function',
            default: null,
            description: 'This function enables to move objects horizontally and vertically.'
          },
          change_attr: {
            type: jsPsych.plugins.parameterType.FUNCTION,
            pretty_name: 'Change attributes',
            default: null,
            description: 'This function enables to change attributes of objects immediately before drawing.'
          },
          is_frame: {
            type: jsPsych.plugins.parameterType.BOOL,
            pretty_name: 'time is in frames',
            default: false,
            description: 'If true, time is treated in frames.'
          },
          origin_center: {
            type: jsPsych.plugins.parameterType.BOOL,
            pretty_name: 'origin_center',
            default: false,
            description: 'The origin is the center of the window.'
          },
          is_presented: {
            type: jsPsych.plugins.parameterType.BOOL,
            pretty_name: 'is_presented',
            default: false,
            description: 'This will be true when the stimulus is presented.'
          },
          trial_ends_after_audio: {
            type: jsPsych.plugins.parameterType.BOOL,
            pretty_name: 'Trial ends after audio',
            default: false,
            description: 'If true, then the trial will end as soon as the audio file finishes playing.'
          },
          tilt: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'tilt',
            default: 0,
            description: 'The tilt of the gabor patch.'
          },
          sf: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'spatial frequency',
            default: 0.05,
            description: 'The spatial frequency of the gabor patch.'
          },
          phase: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'phase',
            default: 0,
            description: 'The phase (degrees) of the gabor patch.'
          },
          sc: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'standard deviation',
            default: 20,
            description: 'The standard deviation of the distribution.'
          },
          contrast: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'contrast',
            default: 20,
            description: 'The contrast of the gabor patch.'
          },
          drift: {
            type: jsPsych.plugins.parameterType.FLOAT,
            pretty_name: 'drift',
            default: 0,
            description: 'The velocity of the drifting gabor patch.'
          },
          method: {
            type: jsPsych.plugins.parameterType.STRING,
            pretty_name: 'gabor_drawing_method',
            default: 'numeric',
            description: 'The method of drawing the gabor patch.'
          },
          disableNorm: {
            type: jsPsych.plugins.parameterType.BOOL,
            pretty_name: 'disableNorm',
            default: false,
            description: 'Disable normalization of the gaussian function.'
          },
          mask_func: {
            type: jsPsych.plugins.parameterType.FUNCTION,
            pretty_name: 'Masking function',
            default: null,
            description: 'Masking the image manually.'
          },

        }
      },
      choices: {
        type: jsPsych.plugins.parameterType.KEYCODE,
        array: true,
        pretty_name: 'Choices',
        default: jsPsych.ALL_KEYS,
        description: 'The keys the subject is allowed to press to respond to the stimulus.'
      },
      prompt: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Prompt',
        default: null,
        description: 'Any content here will be displayed below the stimulus.'
      },
      canvas_width: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Canvas width',
        default: window.innerWidth,
        description: 'The width of the canvas.'
      },
      canvas_height: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Canvas height',
        default: window.innerHeight,
        description: 'The height of the canvas.'
      },
      trial_duration: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Trial duration',
        default: null,
        description: 'How long to show trial before it ends.'
      },
      response_ends_trial: {
        type: jsPsych.plugins.parameterType.BOOL,
        pretty_name: 'Response ends trial',
        default: true,
        description: 'If true, trial will end when subject makes a response.'
      },
      background_color: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Background color',
        default: 'grey',
        description: 'The background color of the canvas.'
      },
      response_type: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'key, mouse or button',
        default: 'key',
        description: 'How to make a response.'
      },
      response_start_time: {
        type: jsPsych.plugins.parameterType.INT,
        pretty_name: 'Response start',
        default: 0,
        description: 'When the subject is allowed to respond to the stimulus.'
      },
      raf_func: {
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Step function',
        default: null,
        description: 'This function enables to move objects as you wish.'        
      },
      mouse_down_func: {
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Mouse down function',
        default: null,
        description: 'This function is set to the event listener of the mousedown.'        
      },
      mouse_move_func: {
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Mouse move function',
        default: null,
        description: 'This function is set to the event listener of the mousemove.'        
      },
      mouse_up_func: {
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Mouse up function',
        default: null,
        description: 'This function is set to the event listener of the mouseup.'        
      },
      key_down_func:{
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Key down function',
        default: null,
        description: 'This function is set to the event listener of the keydown.'              
      },
      key_up_func:{
        type: jsPsych.plugins.parameterType.FUNCTION,
        pretty_name: 'Key up function',
        default: null,
        description: 'This function is set to the event listener of the keyup.'              
      },
      button_choices: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Button choices',
        // default: undefined,
        default: ['Next'],
        array: true,
        description: 'The labels for the buttons.'
      },
      button_html: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Button HTML',
        default: '<button class="jspsych-btn">%choice%</button>',
        array: true,
        description: 'The html of the button. Can create own style.'
      },
      vert_button_margin: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Margin vertical',
        default: '0px',
        description: 'The vertical margin of the button.'
      },
      horiz_button_margin: {
        type: jsPsych.plugins.parameterType.STRING,
        pretty_name: 'Margin horizontal',
        default: '8px',
        description: 'The horizontal margin of the button.'
      },
      clear_canvas: {
        type: jsPsych.plugins.parameterType.BOOL,
        pretty_name: 'clear_canvas',
        default: true,
        description: 'Clear the canvas per frame.'
      }
    }
  }
    
  plugin.trial = function(display_element, trial) {

    // returns an array starting with 'start_num' of which length is 'count'.
    function getNumbering(start_num, count) {
      return [...Array(count)].map((_, i) => i + start_num) 
    }

    // Class for visual and audio stimuli
    class psychophysics_stimulus {
      constructor(stim) {
        Object.assign(this, stim)
        const keys = Object.keys(this)
        for (var i = 0; i < keys.length; i++) {
            if (typeof this[keys[i]] === "function") {
              // オブジェクト内のfunctionはここで指定する必要がある。そうしないとここで即時に実行されて、その結果が関数名に代入される
              if (keys[i] === "drawFunc") continue
              if (keys[i] === "change_attr") continue
              if (keys[i] === "mask_func") continue

              this[keys[i]] = this[keys[i]].call()
            }
        }
      }
    }

    class visual_stimulus extends psychophysics_stimulus {
      constructor(stim) {
        super(stim);
        
        if (this.startX === 'center') {
          if (this.origin_center) {
            this.startX = 0;
          } else {
            this.startX = centerX;
          }
        }
        if (this.startY === 'center') {
          if (this.origin_center) {
            this.startY = 0;
          } else {
            this.startY = centerY;
          }
        }
        if (this.endX === 'center') {
          if (this.origin_center) {
            this.endX = 0;
          } else {
            this.endX = centerX;
          }
        }
        if (this.endY === 'center') {
          if (this.origin_center) {
            this.endY = 0;
          } else {
            this.endY = centerY;
          }
        }

        if (this.origin_center) {
          this.startX = this.startX + centerX;
          this.startY = this.startY + centerY;
          if (this.endX !== null) this.endX = this.endX + centerX;
          if (this.endY !== null) this.endY = this.endY + centerY;
        }

        if (typeof this.motion_start_time === 'undefined') this.motion_start_time = this.show_start_time; // Motion will start at the same time as it is displayed.
        if (typeof this.motion_end_time === 'undefined') this.motion_end_time = null;
        if (typeof this.motion_start_frame === 'undefined') this.motion_start_frame = this.show_start_frame; // Motion will start at the same frame as it is displayed.
        if (typeof this.motion_end_frame === 'undefined') this.motion_end_frame = null;
        
        if (trial.clear_canvas === false && this.show_end_time !== null) alert('You can not specify the show_end_time with the clear_canvas property.');

        // calculate the velocity (pix/sec) using the distance and the time.
        // If the pix_sec is specified, the calc_pix_per_sec returns the intact pix_sec.
        // If the pix_frame is specified, the calc_pix_per_sec returns an undefined.
        this.horiz_pix_sec = this.calc_pix_per_sec('horiz');
        this.vert_pix_sec = this.calc_pix_per_sec('vert');

        // currentX/Y is changed per frame.
        this.currentX = this.startX;
        this.currentY = this.startY;

      }

      calc_pix_per_sec (direction){
        let pix_sec , pix_frame, startPos, endPos;
        if (direction === 'horiz'){
          pix_sec = this.horiz_pix_sec;
          pix_frame = this.horiz_pix_frame;
          startPos = this.startX;
          endPos = this.endX;
        } else {
          pix_sec = this.vert_pix_sec;
          pix_frame = this.vert_pix_frame;
          startPos = this.startY;
          endPos = this.endY;
        }
        const motion_start_time = this.motion_start_time;
        const motion_end_time = this.motion_end_time;
        if ((typeof pix_sec !== 'undefined' || typeof pix_frame !== 'undefined') && endPos !== null && motion_end_time !== null) {
          alert('You can not specify the speed, location, and time at the same time.');
          pix_sec = 0; // stop the motion
        }
        
        if (typeof pix_sec !== 'undefined' || typeof pix_frame !== 'undefined') return pix_sec; // returns an 'undefined' when you specify the pix_frame.
  
        // The velocity is not specified
            
        if (endPos === null) return 0; // This is not motion.
  
        if (startPos === endPos) return 0; // This is not motion.
        
  
        // The distance is specified
  
        if (motion_end_time === null) { // Only the distance is known
          alert('Please specify the motion_end_time or the velocity when you use the endX/Y property.')
          return 0; // stop the motion
        }
  
        return (endPos - startPos)/(motion_end_time/1000 - motion_start_time/1000);
      }

      calc_current_position (direction, elapsed){
        let pix_frame, pix_sec, current_pos, start_pos, end_pos;

        if (direction === 'horiz'){
          pix_frame = this.horiz_pix_frame
          pix_sec = this.horiz_pix_sec
          current_pos = this.currentX
          start_pos = this.startX
          end_pos = this.endX
        } else {
          pix_frame = this.vert_pix_frame
          pix_sec = this.vert_pix_sec
          current_pos = this.currentY
          start_pos = this.startY
          end_pos = this.endY
        }

        const motion_start = this.is_frame ? this.motion_start_frame : this.motion_start_time;
        const motion_end = this.is_frame ? this.motion_end_frame : this.motion_end_time;

        if (elapsed < motion_start) return current_pos
        if (motion_end !== null && elapsed >= motion_end) return current_pos

        // Note that: You can not specify the speed, location, and time at the same time.

        let ascending = true; // true = The object moves from left to right, or from up to down.

        if (typeof pix_frame === 'undefined'){ // In this case, pix_sec is defined.
          if (pix_sec < 0) ascending = false;
        } else {
          if (pix_frame < 0) ascending = false;
        }

        if (end_pos === null || (ascending && current_pos <= end_pos) || (!ascending && current_pos >= end_pos)) {
          if (typeof pix_frame === 'undefined'){ // In this case, pix_sec is defined.
            return start_pos + Math.round(pix_sec * (elapsed - motion_start)/1000); // This should be calculated in seconds.
          } else {
            return current_pos + pix_frame; 
          }
        } else {
          return current_pos
        }
      }

      update_position(elapsed){
        this.currentX = this.calc_current_position ('horiz', elapsed)
        this.currentY = this.calc_current_position ('vert', elapsed)
      }
    }

    class image_stimulus extends visual_stimulus {
      constructor(stim){
        super(stim);

        if (typeof this.file === 'undefined') {
          alert('You have to specify the file property.');
          return;
        }
        this.img = new Image();
        this.img.src = this.file;

        if (typeof this.mask !== 'undefined' || typeof this.filter !== 'undefined') {
          // For masking and filtering, draw the image on another canvas and get its pixel data using the getImageData function.
          // In addition, masking does work only online, that is, the javascript and image files must be uploaded on the web server.

          if (document.getElementById('invisible_canvas') === null) {
            const canvas_element = document.createElement('canvas');
            canvas_element.id = 'invisible_canvas';
            display_element.appendChild(canvas_element)
            canvas_element.style.display = 'none'
          } 

          const invisible_canvas = document.getElementById('invisible_canvas');
          invisible_canvas.width = this.img.width // The width/height of the canvas is not automatically adjusted.
          invisible_canvas.height = this.img.height
          const invisible_ctx = invisible_canvas.getContext('2d');
          invisible_ctx.clearRect(0, 0, invisible_canvas.width, invisible_canvas.height);

          if (typeof this.filter === 'undefined') {
            invisible_ctx.filter = 'none'
          } else {
            invisible_ctx.filter = this.filter
          }
  
          invisible_ctx.drawImage(this.img, 0, 0, this.img.width, this.img.height);

          if (typeof this.mask === 'undefined'){ // Filtering only
            const invisible_img = invisible_ctx.getImageData(0, 0, this.img.width, this.img.height);
            this.masking_img = invisible_img;
            return
          }

          if (this.mask === 'manual'){
            if (this.mask_func === null) {
              alert('You have to specify the mask_func when applying masking manually.');
              return;
            }
            this.masking_img = this.mask_func(invisible_canvas);
            return
          }
    
          if (this.mask === 'gauss'){
            if (typeof this.width === 'undefined') {
              alert('You have to specify the width property for the gaussian mask. For example, 200.');
              return;
            }
            const gauss_width = this.width
            
            // 画像の全体ではなく、フィルタリングを行う部分だけを取り出す
            // Getting only the areas to be filtered, not the whole image.
            const invisible_img = invisible_ctx.getImageData(this.img.width/2 - gauss_width/2, this.img.height/2 - gauss_width/2, gauss_width, gauss_width);

            let coord_array = getNumbering(Math.round(0 - gauss_width/2), gauss_width)
            let coord_matrix_x = []
            for (let i = 0; i< gauss_width; i++){
              coord_matrix_x.push(coord_array)
            }
    
            coord_array = getNumbering(Math.round(0 - gauss_width/2), gauss_width)
            let coord_matrix_y = []
            for (let i = 0; i< gauss_width; i++){
              coord_matrix_y.push(coord_array)
            }
    
            let exp_value;
            if (this.method === 'math') {
              const matrix_x = math.matrix(coord_matrix_x) // Convert to Matrix data
              const matrix_y = math.transpose(math.matrix(coord_matrix_y))
              const x_factor = math.multiply(-1, math.square(matrix_x))
              const y_factor = math.multiply(-1, math.square(matrix_y))
              const varScale = 2 * math.square(this.sc)
              const tmp = math.add(math.divide(x_factor, varScale), math.divide(y_factor, varScale));
              exp_value = math.exp(tmp)
            } else { // numeric
              const matrix_x = coord_matrix_x
              const matrix_y = numeric.transpose(coord_matrix_y)
              const x_factor = numeric.mul(-1, numeric.pow(matrix_x, 2))
              const y_factor = numeric.mul(-1, numeric.pow(matrix_y, 2))
              const varScale = 2 * numeric.pow([this.sc], 2)
              const tmp = numeric.add(numeric.div(x_factor, varScale), numeric.div(y_factor, varScale));
              exp_value = numeric.exp(tmp)
            }
          
            let cnt = 3;
            for (let i = 0; i < gauss_width; i++) {
              for (let j = 0; j < gauss_width; j++) {
                invisible_img.data[cnt] = exp_value[i][j] * 255 // 透明度を変更
                cnt = cnt + 4;
              }
            }
            this.masking_img = invisible_img;
            return
          }

          if (this.mask === 'circle' || this.mask === 'rect'){
            if (typeof this.width === 'undefined') {
              alert('You have to specify the width property for the circle/rect mask.');
              return;
            }
            if (typeof this.height === 'undefined') {
              alert('You have to specify the height property for the circle/rect mask.');
              return;
            }
            if (typeof this.center_x === 'undefined') {
              alert('You have to specify the center_x property for the circle/rect mask.');
              return;
            }
            if (typeof this.center_y === 'undefined') {
              alert('You have to specify the center_y property for the circle/rect mask.');
              return;
            }

            const oval_width = this.width
            const oval_height = this.height
            const oval_cx = this.center_x
            const oval_cy = this.center_y
                        
            // 画像の全体ではなく、フィルタリングを行う部分だけを取り出す
            // Getting only the areas to be filtered, not the whole image.
            const invisible_img = invisible_ctx.getImageData(oval_cx - oval_width/2, oval_cy - oval_height/2, oval_width, oval_height);

            const cx = invisible_img.width/2
            const cy = invisible_img.height/2

            if (this.mask === 'circle'){
              let cnt = 3;
              for (let j = 0; j < oval_height; j++) {
                for (let i = 0; i < oval_width; i++) {
                  const tmp = Math.pow(i-cx, 2)/Math.pow(cx, 2) + Math.pow(j-cy, 2)/Math.pow(cy, 2)
                  if (tmp > 1){
                    invisible_img.data[cnt] = 0 // invisible
                  }
                  cnt = cnt + 4;
                }
              }
            }

            // When this.mask === 'rect', the alpha (transparency) value does not chage at all.

            this.masking_img = invisible_img;
            return
          }
        }  
      }

      show(){
        if (this.mask || this.filter){
          // Note that filtering is done to the invisible_ctx.
          ctx.putImageData(this.masking_img, this.currentX - this.masking_img.width/2, this.currentY - this.masking_img.height/2);
        } else {
          const scale = typeof this.scale === 'undefined' ? 1:this.scale;
          const tmpW = this.img.width * scale;
          const tmpH = this.img.height * scale;              
          ctx.drawImage(this.img, 0, 0, this.img.width, this.img.height, this.currentX - tmpW / 2, this.currentY - tmpH / 2, tmpW, tmpH);   
        }
      }
    }

    class gabor_stimulus extends visual_stimulus {
      constructor(stim){
        super(stim);
        this.update_count = 0;
      }

      show(){
        ctx.putImageData(this.img_data, this.currentX - this.img_data.width/2, this.currentY - this.img_data.height/2)
      }

      update_position(elapsed){
        
        this.currentX = this.calc_current_position ('horiz', elapsed)
        this.currentY = this.calc_current_position ('vert', elapsed)

        if (typeof this.img_data !== 'undefined' && this.drift === 0) return

        let gabor_data;
        // console.log(this.method)

        // The following calculation method is based on Psychtoolbox (MATLAB), 
        // although it doesn't use procedural texture mapping.
        // I also have referenced the gaborgen-js code: https://github.com/jtth/gaborgen-js 

        // You can choose either the numeric.js or the math.js as the method for drawing gabor patches.
        // The numeric.js is considerably faster than the math.js, but the latter is being developed more aggressively than the former.
        // Note that "Math" and "math" are not the same.

        let coord_array = getNumbering(Math.round(0 - this.width/2), this.width)
        let coord_matrix_x = []
        for (let i = 0; i< this.width; i++){
          coord_matrix_x.push(coord_array)
        }

        coord_array = getNumbering(Math.round(0 - this.width/2), this.width)
        let coord_matrix_y = []
        for (let i = 0; i< this.width; i++){
          coord_matrix_y.push(coord_array)
        }

        const tilt_rad = deg2rad(90 - this.tilt)

        // These values are scalars.
        const a = Math.cos(tilt_rad) * this.sf * (2 * Math.PI) // radians
        const b = Math.sin(tilt_rad) * this.sf * (2 * Math.PI)
        let multConst = 1 / (Math.sqrt(2*Math.PI) * this.sc) 
        if (this.disableNorm) multConst = 1

        
        // const phase_rad = deg2rad(this.phase)
        const phase_rad = deg2rad(this.phase + this.drift * this.update_count)
        this.update_count += 1

        if (this.method === 'math') {
          const matrix_x = math.matrix(coord_matrix_x) // Convert to Matrix data
          const matrix_y = math.transpose(math.matrix(coord_matrix_y))
          const x_factor = math.multiply(-1, math.square(matrix_x))
          const y_factor = math.multiply(-1, math.square(matrix_y))
          const tmp1 = math.add(math.multiply(a, matrix_x), math.multiply(b, matrix_y), phase_rad) // radians
          const sinWave = math.sin(tmp1)
          const varScale = 2 * math.square(this.sc)
          const tmp2 = math.add(math.divide(x_factor, varScale), math.divide(y_factor, varScale));
          const exp_value = math.exp(tmp2)
          const tmp3 = math.dotMultiply(exp_value, sinWave)
          const tmp4 = math.multiply(multConst, tmp3)
          const tmp5 = math.multiply(this.contrast, tmp4)
          const m = math.multiply(256, math.add(0.5, tmp5))
          gabor_data = m._data
        } else { // numeric
          const matrix_x = coord_matrix_x
          const matrix_y = numeric.transpose(coord_matrix_y)
          const x_factor = numeric.mul(-1, numeric.pow(matrix_x, 2))
          const y_factor = numeric.mul(-1, numeric.pow(matrix_y, 2))
          const tmp1 = numeric.add(numeric.mul(a, matrix_x), numeric.mul(b, matrix_y), phase_rad) // radians
          const sinWave = numeric.sin(tmp1)
          const varScale = 2 * numeric.pow([this.sc], 2)
          const tmp2 = numeric.add(numeric.div(x_factor, varScale), numeric.div(y_factor, varScale));
          const exp_value = numeric.exp(tmp2)
          const tmp3 = numeric.mul(exp_value, sinWave)
          const tmp4 = numeric.mul(multConst, tmp3)
          const tmp5 = numeric.mul(this.contrast, tmp4)
          const m = numeric.mul(256, numeric.add(0.5, tmp5))
          gabor_data = m
        }
        // console.log(gabor_data)
        const imageData = ctx.createImageData(this.width, this.width);
        let cnt = 0;
        // Iterate through every pixel
        for (let i = 0; i < this.width; i++) {
          for (let j = 0; j < this.width; j++) {
            // Modify pixel data
            imageData.data[cnt] = Math.round(gabor_data[i][j]);  // R value
            cnt++;
            imageData.data[cnt] = Math.round(gabor_data[i][j]);  // G
            cnt++;
            imageData.data[cnt] = Math.round(gabor_data[i][j]);  // B
            cnt++;
            imageData.data[cnt] = 255;  // alpha
            cnt++;
          }
        }

        this.img_data = imageData
      }
    }

    class line_stimulus extends visual_stimulus{
      constructor(stim){
        super(stim)

        if (typeof this.angle === 'undefined') {
          if ((typeof this.x1 === 'undefined') || (typeof this.x2 === 'undefined') || (typeof this.y1 === 'undefined') || (typeof this.y2 === 'undefined')){
            alert('You have to specify the angle of lines, or the start (x1, y1) and end (x2, y2) coordinates.');
            return;
          }
          // The start (x1, y1) and end (x2, y2) coordinates are defined.
          // For motion, startX/Y must be calculated.
          this.startX = (this.x1 + this.x2)/2;
          this.startY = (this.y1 + this.y2)/2;
          if (this.origin_center) {
            this.startX = this.startX + centerX;
            this.startY = this.startY + centerY;
          }  
          this.currentX = this.startX;
          this.currentY = this.startY;
          this.angle = Math.atan((this.y2 - this.y1)/(this.x2 - this.x1)) * (180 / Math.PI);
          this.line_length = Math.sqrt((this.x2 - this.x1) ** 2 + (this.y2 - this.y1) ** 2);
        } else {
          if ((typeof this.x1 !== 'undefined') || (typeof this.x2 !== 'undefined') || (typeof this.y1 !== 'undefined') || (typeof this.y2 !== 'undefined'))
            alert('You can not specify the angle and positions of the line at the same time.')
          if (typeof this.line_length === 'undefined') alert('You have to specify the line_length property.');
          
        }
        if (typeof this.line_color === 'undefined') this.line_color = '#000000';
  
      }

      show(){
        if (typeof this.filter === 'undefined') {
          ctx.filter = 'none'
        } else {
          ctx.filter = this.filter
        }

        // common
        ctx.beginPath();            
        ctx.lineWidth = this.line_width;
        ctx.lineJoin = this.lineJoin;
        ctx.miterLimit = this.miterLimit;
        //
        const theta = deg2rad(this.angle);
        const x1 = this.currentX - this.line_length/2 * Math.cos(theta);
        const y1 = this.currentY - this.line_length/2 * Math.sin(theta);
        const x2 = this.currentX + this.line_length/2 * Math.cos(theta);
        const y2 = this.currentY + this.line_length/2 * Math.sin(theta);
        ctx.strokeStyle = this.line_color;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

      }
    }

    class rect_stimulus extends visual_stimulus{
      constructor(stim){
        super(stim)

        if (typeof this.width === 'undefined') alert('You have to specify the width of the rectangle.');
        if (typeof this.height === 'undefined') alert('You have to specify the height of the rectangle.');
        if (typeof this.line_color === 'undefined' && typeof this.fill_color === 'undefined') alert('You have to specify the either of the line_color or fill_color property.');      
  
      }

      show(){
        if (typeof this.filter === 'undefined') {
          ctx.filter = 'none'
        } else {
          ctx.filter = this.filter
        }

        // common
        // ctx.beginPath();            
        ctx.lineWidth = this.line_width;
        ctx.lineJoin = this.lineJoin;
        ctx.miterLimit = this.miterLimit;
        //
        // First, draw a filled rectangle, then an edge.
        if (typeof this.fill_color !== 'undefined') {
          ctx.fillStyle = this.fill_color;
          ctx.fillRect(this.currentX-this.width/2, this.currentY-this.height/2, this.width, this.height); 
        } 
        if (typeof this.line_color !== 'undefined') {
          ctx.strokeStyle = this.line_color;
          ctx.strokeRect(this.currentX-this.width/2, this.currentY-this.height/2, this.width, this.height);
        }      

      }
    }

    class cross_stimulus extends visual_stimulus {
      constructor(stim) {
        super(stim);
        
        if (typeof this.line_length === 'undefined') alert('You have to specify the line_length of the fixation cross.');
        if (typeof this.line_color === 'undefined') this.line_color = '#000000';
      }

      show(){
        if (typeof this.filter === 'undefined') {
          ctx.filter = 'none'
        } else {
          ctx.filter = this.filter
        }

        // common
        ctx.beginPath();            
        ctx.lineWidth = this.line_width;
        ctx.lineJoin = this.lineJoin;
        ctx.miterLimit = this.miterLimit;
        //
        ctx.strokeStyle = this.line_color;
        const x1 = this.currentX;
        const y1 = this.currentY - this.line_length/2;
        const x2 = this.currentX;
        const y2 = this.currentY + this.line_length/2;                
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        const x3 = this.currentX - this.line_length/2;
        const y3 = this.currentY;
        const x4 = this.currentX + this.line_length/2;
        const y4 = this.currentY;                
        ctx.moveTo(x3, y3);
        ctx.lineTo(x4, y4);
        // ctx.closePath();
        ctx.stroke();
      }
    }
  
    class circle_stimulus extends visual_stimulus {
      constructor(stim){
        super(stim);
        
        if (typeof this.radius === 'undefined') alert('You have to specify the radius of circles.');
        if (typeof this.line_color === 'undefined' && typeof this.fill_color === 'undefined') alert('You have to specify the either of line_color or fill_color.');      
      }

      show(){
        if (typeof this.filter === 'undefined') {
          ctx.filter = 'none'
        } else {
          ctx.filter = this.filter
        }

        // common
        ctx.beginPath();            
        ctx.lineWidth = this.line_width;
        ctx.lineJoin = this.lineJoin;
        ctx.miterLimit = this.miterLimit;
        //
        if (typeof this.fill_color !== 'undefined') {
          ctx.fillStyle = this.fill_color;
          ctx.arc(this.currentX, this.currentY, this.radius, 0, Math.PI*2, false);
          ctx.fill();
        } 
        if (typeof this.line_color !== 'undefined') {
          ctx.strokeStyle = this.line_color;
          ctx.arc(this.currentX, this.currentY, this.radius, 0, Math.PI*2, false);
          ctx.stroke();
        }

      }
    }
    
    class text_stimulus extends visual_stimulus {
      constructor(stim){
        super(stim)

        if (typeof this.content === 'undefined') alert('You have to specify the content of texts.');
        if (typeof this.text_color === 'undefined') this.text_color = '#000000';
        if (typeof this.text_space === 'undefined') this.text_space = 20;
  
      }

      show(){
        if (typeof this.filter === 'undefined') {
          ctx.filter = 'none'
        } else {
          ctx.filter = this.filter
        }

        // common
        // ctx.beginPath();            
        ctx.lineWidth = this.line_width;
        ctx.lineJoin = this.lineJoin;
        ctx.miterLimit = this.miterLimit;
        //
        if (typeof this.font !== 'undefined') ctx.font = this.font;

        ctx.fillStyle = this.text_color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle"

        let column = [''];
        let line = 0;
        for (let i = 0; i < this.content.length; i++) {
            let char = this.content.charAt(i);

            if (char == "\n") {    
                line++;
                column[line] = '';
            } else {
              column[line] += char;
            }
        }

        for (let i = 0; i < column.length; i++) {
            ctx.fillText(column[i], this.currentX, this.currentY - this.text_space * (column.length-1) / 2 + this.text_space * i);
        }

      }
    }

    class manual_stimulus extends visual_stimulus{
      constructor(stim){
        super(stim)
      }

      show(){}
    }

    class audio_stimulus extends psychophysics_stimulus{
      constructor(stim){
        super(stim)

        if (typeof this.file === 'undefined') {
          alert('You have to specify the file property.')
          return;
        }

        // setup stimulus
        this.context = jsPsych.pluginAPI.audioContext();

        // load audio file
        jsPsych.pluginAPI.getAudioBuffer(this.file)
          .then(function (buffer) {
            if (this.context !== null) {
              this.audio = this.context.createBufferSource();
              this.audio.buffer = buffer;
              this.audio.connect(this.context.destination);
              console.log('WebAudio')
            } else {
              this.audio = buffer;
              this.audio.currentTime = 0;
              console.log('HTML5 audio')
            }
            // setupTrial();
          }.bind(this))
          .catch(function (err) {
            console.error(`Failed to load audio file "${this.file}". Try checking the file path. We recommend using the preload plugin to load audio files.`)
            console.error(err)
          }.bind(this));

  
        // set up end event if trial needs it
        if (this.trial_ends_after_audio) {
          this.audio.addEventListener('ended', end_trial);
        }
      }
  
      play(){
        // start audio
        if(this.context !== null){
          //startTime = this.context.currentTime; 
          // オリジナルのjspsychではwebaudioが使えるときは時間のデータとしてcontext.currentTimeを使っている。
          // psychophysicsプラグインでは、performance.now()で統一している
          this.audio.start(this.context.currentTime);
        } else {
          this.audio.play();
        }
      }

      stop(){
        if(this.context !== null){
          this.audio.stop();
          // this.source.onended = function() { }
        } else {
          this.audio.pause();
          
        }
        this.audio.removeEventListener('ended', end_trial);

      }
    }

    if (typeof trial.stepFunc !== 'undefined') alert(`The stepFunc is no longer supported. Please use the raf_func instead.`)

    const elm_jspsych_content = document.getElementById('jspsych-content');
    const style_jspsych_content = window.getComputedStyle(elm_jspsych_content); // stock
    const default_maxWidth = style_jspsych_content.maxWidth;
    elm_jspsych_content.style.maxWidth = 'none'; // The default value is '95%'. To fit the window.

    let new_html = '<canvas id="myCanvas" class="jspsych-canvas" width=' + trial.canvas_width + ' height=' + trial.canvas_height + ' style="background-color:' + trial.background_color + ';"></canvas>';

    const motion_rt_method = 'performance'; // 'date' or 'performance'. 'performance' is better.
    let start_time; // used for mouse and button responses.
    let keyboardListener;

    // allow to respond using keyboard mouse or button
    jsPsych.pluginAPI.setTimeout(function() {
      if (trial.response_type === 'key'){
        if (trial.choices != jsPsych.NO_KEYS) {
          keyboardListener = jsPsych.pluginAPI.getKeyboardResponse({
            callback_function: after_response,
            valid_responses: trial.choices,
            rt_method: motion_rt_method,
            persist: false,
            allow_held_key: false
          });
        }  
      } else if (trial.response_type === 'mouse')  {

        if (motion_rt_method == 'date') {
          start_time = (new Date()).getTime();
        } else {
          start_time = performance.now();
        }

        canvas.addEventListener("mousedown", mouseDownFunc);
      } else { // button
        start_time = performance.now();
        for (let i = 0; i < trial.button_choices.length; i++) {
          display_element.querySelector('#jspsych-image-button-response-button-' + i).addEventListener('click', function(e){
            const choice = e.currentTarget.getAttribute('data-choice'); // don't use dataset for jsdom compatibility
            // after_response(choice);
            // console.log(performance.now())
            // console.log(start_time)
            after_response({
              key: -1,
              rt: performance.now() - start_time,
              button: choice,
          });
    
          });
        }
      }
    }, trial.response_start_time);

    //display buttons
    if (trial.response_type === 'button'){
      let buttons = [];
      if (Array.isArray(trial.button_html)) {
        if (trial.button_html.length == trial.button_choices.length) {
          buttons = trial.button_html;
        } else {
          console.error('Error: The length of the button_html array does not equal the length of the button_choices array');
        }
      } else {
        for (let i = 0; i < trial.button_choices.length; i++) {
          buttons.push(trial.button_html);
        }
      }
      new_html += '<div id="jspsych-image-button-response-btngroup">';
      for (let i = 0; i < trial.button_choices.length; i++) {
        let str = buttons[i].replace(/%choice%/g, trial.button_choices[i]);
        new_html += '<div class="jspsych-image-button-response-button" style="display: inline-block; margin:'+trial.vert_button_margin+' '+trial.horiz_button_margin+'" id="jspsych-image-button-response-button-' + i +'" data-choice="'+i+'">'+str+'</div>';
      }
      new_html += '</div>';
  
    }
    

    // add prompt
    if(trial.prompt !== null){
      new_html += trial.prompt;
    }

    // draw
    display_element.innerHTML = new_html;


    const canvas = document.getElementById('myCanvas');
    if ( ! canvas || ! canvas.getContext ) {
      alert('This browser does not support the canvas element.');
      return;
    }
    const ctx = canvas.getContext('2d');

    trial.canvas = canvas;
    trial.context = ctx;
    
    const centerX = canvas.width/2;
    const centerY = canvas.height/2;
    trial.centerX = centerX;
    trial.centerY = centerY;
    
    // add event listeners defined by experimenters.
    if (trial.mouse_down_func !== null){
      canvas.addEventListener("mousedown", trial.mouse_down_func);
    }

    if (trial.mouse_move_func !== null){
      canvas.addEventListener("mousemove", trial.mouse_move_func);
    }

    if (trial.mouse_up_func !== null){
      canvas.addEventListener("mouseup", trial.mouse_up_func);
    }
    
    if (trial.key_down_func !== null){
      document.addEventListener("keydown", trial.key_down_func); // It doesn't work if the canvas is specified instead of the document.
    }

    if (trial.key_up_func !== null){
      document.addEventListener("keyup", trial.key_up_func);
    }

    if (typeof trial.stimuli === 'undefined' && trial.raf_func === null){
      alert('You have to specify the stimuli/raf_func parameter in the psychophysics plugin.')
      return
    }

 
    /////////////////////////////////////////////////////////
    // make instances
    const oop_stim = []
    const set_instance = {
      sound: audio_stimulus,
      image: image_stimulus,
      line: line_stimulus,
      rect: rect_stimulus,
      circle: circle_stimulus,
      text: text_stimulus,
      cross: cross_stimulus,
      manual: manual_stimulus,
      gabor: gabor_stimulus
    }
    if (typeof trial.stimuli !== 'undefined') { // The stimuli could be 'undefined' if the raf_func is specified.
      for (let i = 0; i < trial.stimuli.length; i++){
        const stim = trial.stimuli[i];
        if (typeof stim.obj_type === 'undefined'){
          alert('You have missed to specify the obj_type property in the ' + (i+1) + 'th object.');
          return
        }
        oop_stim.push(new set_instance[stim.obj_type](stim))
      }
    }
    trial.stim_array = oop_stim
    // for (let i = 0; i < trial.stim_array.length; i++){
    //   console.log(trial.stim_array[i].is_presented)
    // }

    function mouseDownFunc(e){
      
      let click_time;
      
      if (motion_rt_method == 'date') {
        click_time = (new Date()).getTime();
      } else {
        click_time = performance.now();
      }
      
      e.preventDefault();
      
      after_response({
          key: -1,
          rt: click_time - start_time,
          // clickX: e.clientX,
          // clickY: e.clientY,
          clickX: e.offsetX,
          clickY: e.offsetY,
      });
    }

    let startStep = null;
    let sumOfStep;
    let elapsedTime;
    //let currentX, currentY;
    function step(timestamp){
      if (!startStep) {
        startStep = timestamp;
        sumOfStep = 0;
      } else {
        sumOfStep += 1;
      }
      elapsedTime = timestamp - startStep; // unit is ms. This can be used within the raf_func().

      if (trial.clear_canvas)
        ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (trial.raf_func !== null) {        
        trial.raf_func(trial, elapsedTime, sumOfStep); // customize
        frameRequestID = window.requestAnimationFrame(step);
        return
      }

      for (let i = 0; i < trial.stim_array.length; i++){
        const stim = trial.stim_array[i];
        const elapsed = stim.is_frame ? sumOfStep : elapsedTime;
        const show_start = stim.is_frame ? stim.show_start_frame : stim.show_start_time;
        const show_end = stim.is_frame ? stim.show_end_frame : stim.show_end_time;

        if (stim.obj_type === 'sound'){
          if (elapsed >= show_start && !stim.is_presented){
            stim.play(); // play the sound.
            stim.is_presented = true;
          }
          continue;
        }

        // visual stimuli
        if (elapsed < show_start) continue;
        if (show_end !== null && elapsed >= show_end) continue;
        if (trial.clear_canvas === false && stim.is_presented) continue;

        stim.update_position(elapsed);

        if (stim.drawFunc !== null) {
          stim.drawFunc(stim, canvas, ctx);
        } else {
          if (stim.change_attr != null) stim.change_attr(stim, elapsedTime, sumOfStep)
          stim.show()
        }
        stim.is_presented = true;
      }
      frameRequestID = window.requestAnimationFrame(step);
    }
    
    // Start the step function.
    let frameRequestID = window.requestAnimationFrame(step);

    
    function deg2rad(degrees){
      return degrees / 180 * Math.PI;
    }

    // store response
    let response = {
      rt: null,
      key: null
    };

    // function to end trial when it is time
    // let end_trial = function() { // This causes an initialization error at stim.audio.addEventListener('ended', end_trial); 
    function end_trial(){
      // console.log(default_maxWidth)
      document.getElementById('jspsych-content').style.maxWidth = default_maxWidth; // restore
      window.cancelAnimationFrame(frameRequestID); //Cancels the frame request
      canvas.removeEventListener("mousedown", mouseDownFunc);

      // remove event listeners defined by experimenters.
      if (trial.mouse_down_func !== null){
        canvas.removeEventListener("mousedown", trial.mouse_down_func);
      }
  
      if (trial.mouse_move_func !== null){
        canvas.removeEventListener("mousemove", trial.mouse_move_func);
      }
  
      if (trial.mouse_up_func !== null){
        canvas.removeEventListener("mouseup", trial.mouse_up_func);
      }
  
      if (trial.key_down_func !== null){
        document.removeEventListener("keydown", trial.key_down_func);
      }

      if (trial.key_up_func !== null){
        document.removeEventListener("keyup", trial.key_up_func);
      }

      // stop the audio file if it is playing
      // remove end event listeners if they exist
      if (typeof trial.stim_array !== 'undefined') { // The stimuli could be 'undefined' if the raf_func is specified.
        for (let i = 0; i < trial.stim_array.length; i++){
          const stim = trial.stim_array[i];
          // stim.is_presented = false;
          // if (typeof stim.context !== 'undefined') { // If the stimulus is audio data
          if (stim.obj_type === 'sound') { // If the stimulus is audio data
            stim.stop();
          }
        }
      }

      // kill any remaining setTimeout handlers
      jsPsych.pluginAPI.clearAllTimeouts();

      // kill keyboard listeners
      if (typeof keyboardListener !== 'undefined') {
        jsPsych.pluginAPI.cancelKeyboardResponse(keyboardListener);
      }

      // gather the data to store for the trial //音の再生時からの反応時間をとるわけではないから不要？
      // if(context !== null && response.rt !== null){
      //   response.rt = Math.round(response.rt * 1000);
      // }

      // gather the data to store for the trial
      const trial_data = {}
      trial_data['rt'] = response.rt;
      trial_data['response_type'] = trial.response_type;
      trial_data['key_press'] = response.key;
      trial_data['response'] = response.key; // compatible with the jsPsych >= 6.3.0
      trial_data['avg_frame_time'] = elapsedTime/sumOfStep;
      trial_data['center_x'] = centerX;
      trial_data['center_y'] = centerY;

      if (trial.response_type === 'mouse'){
        trial_data['click_x'] = response.clickX;
        trial_data['click_y'] = response.clickY;
      } else if (trial.response_type === 'button'){
        trial_data['button_pressed'] = response.button;
      }

      // clear the display
      display_element.innerHTML = '';

      // move on to the next trial
      jsPsych.finishTrial(trial_data);
    }

    // function to handle responses by the subject
    // let after_response = function(info) { // This causes an initialization error at stim.audio.addEventListener('ended', end_trial); 
    function after_response(info) {

      // after a valid response, the stimulus will have the CSS class 'responded'
      // which can be used to provide visual feedback that a response was recorded
      //display_element.querySelector('#jspsych-html-keyboard-response-stimulus').className += ' responded';

      // only record the first response
      if (response.key == null) {
        response = info;
      }

      if (trial.response_type === 'button'){
        // after a valid response, the stimulus will have the CSS class 'responded'
        // which can be used to provide visual feedback that a response was recorded
        // display_element.querySelector('#jspsych-image-button-response-stimulus').className += ' responded';

        // disable all the buttons after a response
        let btns = document.querySelectorAll('.jspsych-image-button-response-button button');
        for(let i=0; i<btns.length; i++){
          //btns[i].removeEventListener('click');
          btns[i].setAttribute('disabled', 'disabled');
        }
      }

      if (trial.response_ends_trial) {
        end_trial();
      }
    }

    // end trial if trial_duration is set
    if (trial.trial_duration !== null) {
      jsPsych.pluginAPI.setTimeout(function() {
        end_trial();
      }, trial.trial_duration);
    }

  };

  return plugin;
})();
</script>
<script>
var fac = {
  angles: [60, 120, 240, 300], // 角度
  comp_len: [90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220], // 系列
};
</script>
<script>/**
 * キソジオンライン ミュラーリヤー錯視実験
 * 
 * 恒常法
 * - 内向 or 外向
 * - 90〜220まで10 pxごとにランダム
 * - 各条件10試行（14 長さ x 2 向き x 10 rep = 280 試行）
 *
 * by kohske takahashi
 *
 * MIT License | https://github.com/kohske/KisojiOnline/blob/master/LICENSE
 */

// 表示領域サイズ
var canvas_width = 600;
var canvas_height = 600;

// 実験パラメータ
// 定数
var std_len = 150; // 標準刺激（直線）の長さ
var std_posY = 100; // 標準刺激（ML）のY座標
var std_arrow_len = 50; // 矢羽の長さ

var comp_posY = 200; // 比較刺激のY座標

// 変数
var comp_len; // 比較刺激の長さ
var std_angle; // 標準刺激の角度


// 要因計画は親HTMLで。
//var fac = {
//  angles: [60, 120, 180, 240, 300], // 角度
//  up_down: ["up", "down"], // 系列
//  rept: [1,2],
//};

// 要因の直積
var factors = jsPsych.randomization.factorial(fac, 10);

var n_trial = 1;
var n_trial_all = factors.length;


// 標準刺激
var std_line = {
  obj_type: 'line',
  x1: canvas_width/4.0-std_len/2.0,
  y1: std_posY,
  x2: canvas_width/4.0+std_len/2.0,
  y2: std_posY,
  line_width: 3,
  line_color: "#000000"
};

// 比較刺激の線
var comp_line = {
  obj_type: 'line',
  //  x1: 0,
  //  y1: comp_posY,
  //  x2: 0,
  //  y2: comp_posY,
  startX: 3*canvas_width/4.0,
  startY: comp_posY,
  line_length: 0,
  angle: 0,
  line_width: 3,
  line_color: "#000000"
}

// 標準刺激の矢羽
var std_arrow = {
  obj_type: 'line',
  x1: 0,
  y1: std_posY,
  x2: 0,
  y2: 0,
  line_width: 3,
  line_color: "#000000"
};

var text_object = {
  obj_type: 'text',
  startX: 'center',
  startY: 500,
  content: "",
  font: "22px 'Arial'",
  text_color: 'black',
  text_space: 100,
};

// 刺激提示
var trial = {
  type: 'psychophysics',
  stimuli: [comp_line, std_line, std_arrow, std_arrow, std_arrow, std_arrow, text_object],
  response_type: 'key',
  std_angle: jsPsych.timelineVariable('angles'),
  comp_len: jsPsych.timelineVariable('comp_len'),
  data :{
    std_angle: jsPsych.timelineVariable('angles'),
    comp_len: jsPsych.timelineVariable('comp_len'),
    record: 1
  },
  choices: ["ArrowLeft", "ArrowRight"],
  canvas_width: canvas_width,
  canvas_height:canvas_height,
  background_color: '#DDDDDD',

  // 試行の刺激を設定する
  on_start: function(trial){
    // 矢羽の角度
    var rad = trial.std_angle*Math.PI/180/2;
    var comp_len = trial.comp_len;
    
    // 刺激の座標指定
    trial.stimuli[0].line_length = comp_len;
    
    trial.stimuli[2].x1 = canvas_width/4.0-std_len/2.0;
    trial.stimuli[2].x2 = canvas_width/4.0-std_len/2.0+std_arrow_len*Math.cos(rad);
    trial.stimuli[2].y2 = std_posY+std_arrow_len*Math.sin(rad);

    trial.stimuli[3].x1 = canvas_width/4.0-std_len/2.0,    
    trial.stimuli[3].x2 = canvas_width/4.0-std_len/2.0+std_arrow_len*Math.cos(rad);
    trial.stimuli[3].y2 = std_posY-std_arrow_len*Math.sin(rad);

    trial.stimuli[4].x1 = canvas_width/4.0+std_len/2.0,    
    trial.stimuli[4].x2 = canvas_width/4.0+std_len/2.0-std_arrow_len*Math.cos(rad);
    trial.stimuli[4].y2 = std_posY+std_arrow_len*Math.sin(rad);

    trial.stimuli[5].x1 = canvas_width/4.0+std_len/2.0,    
    trial.stimuli[5].x2 = canvas_width/4.0+std_len/2.0-std_arrow_len*Math.cos(rad);
    trial.stimuli[5].y2 = std_posY-std_arrow_len*Math.sin(rad);

    trial.stimuli[6].content = String(n_trial)+" / "+String(n_trial_all);
    ++n_trial;
  }
};

var test_procedure = {
  timeline: [trial],
  timeline_variables: factors,
  randomize_order: true
}

// 開始時の画面
var start_experiment_procedure = {
  type: 'html-keyboard-response',
  stimulus: '<p><b>ミュラー・リヤーの実験（恒常法）</b></p>',
  choices: [" "],
  prompt: "<p>左と右に横線が出てきます。左の横線には矢羽がついています。<br/><br/>"+
    "右（矢羽がない方）の横線が左の横線（矢羽がある方）よりも短く見えれば「左矢印キー」を、右の横線が左の横線よりも長く見えれば「右矢印キー」を押してください。<br/><br/>"+
    "または、左右どちらの横線の方が長く見えるか、左右の矢印キーで回答してください（意味は同じです）。<br/><br/>"+
    "左右の横線が同じ長さに見える場合でも、どちらが長く見えるか無理矢理判断して回答してください。<br/><br/>"+
    "スペースキーを押すと始まります。"+
    "</p>"
};

// 実験終了時の画面
var finish_experiment_procedure = {
  type: 'html-keyboard-response',
  stimulus: "",
  choices: jsPsych.NO_KEYS,
  on_start: function(trial) {
    var dt = jsPsych.data.get().filter([{record: 1}]);    
    dt = dt.ignore(["response_type", "key_press", "avg_frame_time", "trial_type", "trial_index", "time_elapsed", "internal_node_id", "stimulus", "center_x", "center_y", "record"]);
    var txt = dt.csv().replace(/,/g, "\t").replace(/"/g,"");
    trial.stimulus = '<p>実験終了です。</p><p>muller-lyer-adjustment.csvというファイル名のデータファイルが自動的にダウンロードされています。Excelで開けるので確認してください。</p>'+
      '<p>データファイルがダウンロードできていない場合は、下の枠の中のデータをエクセルなどに貼り付けて保存しましょう。</p>'+
      '<p>枠の中をクリックしてから、Ctrl+A (コントロールキーを押しながらAキーを押す)ですべて選択し、Ctrl+Cでクリップボードにコピーできます。</p>'+
      '<p>コピーしたら、新しいエクセルファイルを開き、Ctrl+Vで貼付けましょう。</p>'+
      '<textarea style="width:450px; height: 300px">'+txt+'</textarea>';
    dt.localSave('csv', 'ML-constant.csv');    
  }
};

jsPsych.init({
  override_safe_mode: true,
  default_iti: 100,
  timeline: [start_experiment_procedure, test_procedure, finish_experiment_procedure]
});
</script>
<textarea id="result" value="1" cols="30" rows="30" maxlength="15" style="display:none"></textarea>



<!-- code folding -->



</body>
</html>
